gfortran -O3 -fimplicit-none -Wall -o ../bin/sord-sO globals.f90 diffcn.f90 diffnc.f90 hourglass.f90 bc.f90 surfnormals.f90 util.f90 frio.f90 serial.f90 arrays.f90 fieldio.f90 stats.f90 parameters.f90 setup.f90 gridgen.f90 material.f90 source.f90 rupture.f90 resample.f90 checkpoint.f90 timestep.f90 stress.f90 acceleration.f90 sord.f90
! Global variables
module m_globals
implicit none

! Input parameters, see default-prm.py for documentation
integer, dimension(3) :: np3, nn, bc1, bc2, n1expand, n2expand
integer :: nt, itstats, itio, itcheck, itstop, npml, ppml, oplevel, fixhypo, mpin, &
    mpout, debug, faultopening, irup, faultnormal, nsource
real :: tm0, dt, dx(3), rho1, rho2, vp1, vp2, vs1, vs2, gam1, gam2, hourglass(2), &
    vdamp, rexpand, affine(9), gridnoise, xhypo(3), ihypo(3), vpml, slipvector(3)
real :: period, source1(3), source2(3), vrup, rcrit, trelax, svtol
character(16) :: source, timefunction

! Miscellaneous parameters
real, parameter :: pi = 3.14159265
real :: &
    mptimer,        & ! MPI timing
    iotimer,        & ! I/O timing
    tm                ! time
integer :: &
    it,             & ! current time step
    ifn,            & ! fault normal component=abs(faultnormal)
    ip,             & ! process rank
    ipid,           & ! processor ID
    np0               ! number of processes available
integer, dimension(3) :: &
    nm,             & ! size of local 3D arrays
    nhalo,          & ! number of ghost nodes
    ip3,            & ! 3D process rank
    ip3root,        & ! 3D master process rank
    i1bc, i2bc,     & ! model boundary
    i1pml, i2pml,   & ! PML boundary
    i1core, i2core, & ! core region
    i1node, i2node, & ! node region
    i1cell, i2cell, & ! cell region
    nnoff             ! offset between local and global indices
logical :: &
    sync,           & ! synchronize processes
    verb,           & ! print messages
    master            ! master process flag
character(256) :: &
    str               ! string for storing file names

! 1D dynamic arrays
real, allocatable, dimension(:) :: &
    dx1, dx2, dx3,  & ! x, y, z rectangular element size
    dn1,            & ! pml node damping -2*d     / (2+d*dt)
    dn2,            & ! pml node damping  2       / (2+d*dt)
    dc1,            & ! pml cell damping (2-d*dt) / (2+d*dt)
    dc2               ! pml cell damping  2*dt    / (2+d*dt)

! PML state
real, allocatable, dimension(:,:,:,:) :: &
    p1, p2, p3,     & ! pml momentum near side
    p4, p5, p6,     & ! pml momentum far side
    g1, g2, g3,     & ! pml gradient near side
    g4, g5, g6        ! pml gradient far side

! B matrix
real, allocatable, dimension(:,:,:,:,:) :: bb

! Volume fields
real, allocatable, target, dimension(:,:,:) :: &
    vc,             & ! cell volume
    mr,             & ! mass ratio
    lam, mu,        & ! Lame parameters
    gam,            & ! viscosity
    qp, qs,         & ! anelastic coefficients
    yy,             & ! hourglass constant
    s1, s2            ! temporary storage
real, allocatable, target, dimension(:,:,:,:) :: &
    xx,             & ! node locations
    vv,             & ! velocity
    uu,             & ! displacement
    z1, z2,         & ! anelastic memory variables
    w1, w2            ! temporary storage

! Fault surface fields
real, allocatable, target, dimension(:,:,:) :: &
    mus, mud,       & ! coefs of static and dynamic friction
    dc,             & ! slip weakening distance
    co,             & ! cohesion
    area,           & ! fault element area
    rhypo,          & ! radius to hypocenter
    lamf, muf,      & ! moduli at the fault nodes
    sl,             & ! slip path length
    psv,            & ! peak slip velocity
    trup,           & ! rupture time
    tarr,           & ! arrest time
    tn, ts, f1, f2    ! temporary storage
real, allocatable, target, dimension(:,:,:,:) :: &
    nhat,           & ! fault surface normals
    t0,             & ! initial traction
    t1, t2, t3        ! temporary storage

end module

! Difference operator, cell to node
module m_diffcn
implicit none
contains

subroutine diffcn( df, f, i, a, i1, i2, oplevel, bb, x, dx1, dx2, dx3, dx )
real, intent(out) :: df(:,:,:)
real, intent(in) :: f(:,:,:,:), bb(:,:,:,:,:), x(:,:,:,:), &
    dx1(:), dx2(:), dx3(:), dx(3)
integer, intent(in) :: i, a, i1(3), i2(3), oplevel
real :: h
integer :: j, k, l, b, c

if ( any( i1 > i2 ) ) return

select case( oplevel )

! Saved B matrix, flops: 8* 7+
case( 6 )
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
    df(j,k,l) = &
    - bb(j,k,l,5,a) * f(j,k,l,i) - f(j-1,k-1,l-1,i) * bb(j-1,k-1,l-1,1,a) &
    - bb(j,k-1,l-1,6,a) * f(j,k-1,l-1,i) - f(j-1,k,l,i) * bb(j-1,k,l,2,a) &
    - bb(j-1,k,l-1,7,a) * f(j-1,k,l-1,i) - f(j,k-1,l,i) * bb(j,k-1,l,3,a) &
    - bb(j-1,k-1,l,8,a) * f(j-1,k-1,l,i) - f(j,k,l-1,i) * bb(j,k,l-1,4,a)
end do
end do
end do

! Constant grid, flops: 1* 7+
case( 1 )
select case( a )
case( 1 )
    h = sign( 0.25 * dx(2) * dx(3), dx(1) )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * &
        ( f(j,k,l,i) - f(j-1,k-1,l-1,i) &
        + f(j,k-1,l-1,i) - f(j-1,k,l,i) &
        - f(j-1,k,l-1,i) + f(j,k-1,l,i) &
        - f(j-1,k-1,l,i) + f(j,k,l-1,i) )
    end do
    end do
    end do
case( 2 )
    h = sign( 0.25 * dx(3) * dx(1), dx(2) )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * &
        ( f(j,k,l,i) - f(j-1,k-1,l-1,i) &
        - f(j,k-1,l-1,i) + f(j-1,k,l,i) &
        + f(j-1,k,l-1,i) - f(j,k-1,l,i) &
        - f(j-1,k-1,l,i) + f(j,k,l-1,i) )
    end do
    end do
    end do
case( 3 )
    h = sign( 0.25 * dx(1) * dx(2), dx(3) )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * &
        ( f(j,k,l,i) - f(j-1,k-1,l-1,i) &
        - f(j,k-1,l-1,i) + f(j-1,k,l,i) &
        - f(j-1,k,l-1,i) + f(j,k-1,l,i) &
        + f(j-1,k-1,l,i) - f(j,k,l-1,i) )
    end do
    end do
    end do
end select

! Rectangular grid, flops: 6* 7+
case( 2 )
h = sign( 0.25, product( dx ) )
select case( a )
case( 1 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
    df(j,k,l) = h * ( &
    dx3(l)   * ( dx2(k) * ( f(j,k,l,i)   - f(j-1,k,l,i) )   + dx2(k-1) * ( f(j,k-1,l,i)   - f(j-1,k-1,l,i)   ) ) + &
    dx3(l-1) * ( dx2(k) * ( f(j,k,l-1,i) - f(j-1,k,l-1,i) ) + dx2(k-1) * ( f(j,k-1,l-1,i) - f(j-1,k-1,l-1,i) ) ) )
    end do
    end do
    end do
case( 2 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
    df(j,k,l) = h * ( &
    dx1(j)   * ( dx3(l) * ( f(j,k,l,i)   - f(j,k-1,l,i) )   + dx3(l-1) * ( f(j,k,l-1,i)   - f(j,k-1,l-1,i)   ) ) + &
    dx1(j-1) * ( dx3(l) * ( f(j-1,k,l,i) - f(j-1,k-1,l,i) ) + dx3(l-1) * ( f(j-1,k,l-1,i) - f(j-1,k-1,l-1,i) ) ) )
    end do
    end do
    end do
case( 3 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
    df(j,k,l) = h * ( &
    dx2(k)   * ( dx1(j) * ( f(j,k,l,i)   - f(j,k,l-1,i) )   + dx1(j-1) * ( f(j-1,k,l,i)   - f(j-1,k,l-1,i)   ) ) + &
    dx2(k-1) * ( dx1(j) * ( f(j,k-1,l,i) - f(j,k-1,l-1,i) ) + dx1(j-1) * ( f(j-1,k-1,l,i) - f(j-1,k-1,l-1,i) ) ) )
    end do
    end do
    end do
end select

! Parallelepiped grid, flops: 33* 47+
case( 3 )
h = sign( 0.25, product( dx ) )
b = modulo( a, 3 ) + 1
c = modulo( a + 1, 3 ) + 1
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
df(j,k,l) = h * &
(f(j,k,l,i)* &
    (x(j+1,k,l,b)*(x(j,k+1,l,c)-x(j,k,l+1,c)) &
    +x(j,k+1,l,b)*(x(j,k,l+1,c)-x(j+1,k,l,c)) &
    +x(j,k,l+1,b)*(x(j+1,k,l,c)-x(j,k+1,l,c))) &
+f(j,k-1,l-1,i)* &
    (x(j+1,k,l,b)*(x(j,k-1,l,c)-x(j,k,l-1,c)) &
    +x(j,k-1,l,b)*(x(j,k,l-1,c)-x(j+1,k,l,c)) &
    +x(j,k,l-1,b)*(x(j+1,k,l,c)-x(j,k-1,l,c))) &
+f(j-1,k,l-1,i)* &
    (x(j,k+1,l,b)*(x(j,k,l-1,c)-x(j-1,k,l,c)) &
    +x(j,k,l-1,b)*(x(j-1,k,l,c)-x(j,k+1,l,c)) &
    +x(j-1,k,l,b)*(x(j,k+1,l,c)-x(j,k,l-1,c))) &
+f(j-1,k-1,l,i)* &
    (x(j,k,l+1,b)*(x(j-1,k,l,c)-x(j,k-1,l,c)) &
    +x(j-1,k,l,b)*(x(j,k-1,l,c)-x(j,k,l+1,c)) &
    +x(j,k-1,l,b)*(x(j,k,l+1,c)-x(j-1,k,l,c))) &
+f(j-1,k-1,l-1,i)* &
    (x(j-1,k,l,b)*(x(j,k,l-1,c)-x(j,k-1,l,c)) &
    +x(j,k-1,l,b)*(x(j-1,k,l,c)-x(j,k,l-1,c)) &
    +x(j,k,l-1,b)*(x(j,k-1,l,c)-x(j-1,k,l,c))) &
+f(j-1,k,l,i)* &
    (x(j-1,k,l,b)*(x(j,k,l+1,c)-x(j,k+1,l,c)) &
    +x(j,k+1,l,b)*(x(j-1,k,l,c)-x(j,k,l+1,c)) &
    +x(j,k,l+1,b)*(x(j,k+1,l,c)-x(j-1,k,l,c))) &
+f(j,k-1,l,i)* &
    (x(j,k-1,l,b)*(x(j+1,k,l,c)-x(j,k,l+1,c)) &
    +x(j,k,l+1,b)*(x(j,k-1,l,c)-x(j+1,k,l,c)) &
    +x(j+1,k,l,b)*(x(j,k,l+1,c)-x(j,k-1,l,c))) &
+f(j,k,l-1,i)* &
    (x(j,k,l-1,b)*(x(j,k+1,l,c)-x(j+1,k,l,c)) &
    +x(j+1,k,l,b)*(x(j,k,l-1,c)-x(j,k+1,l,c)) &
    +x(j,k+1,l,b)*(x(j+1,k,l,c)-x(j,k,l-1,c))))
end do
end do
end do

! General grid one-point quadrature, flops: 33* 119+
case( 4 )
h = sign( 0.0625, product( dx ) )
b = modulo( a, 3 ) + 1
c = modulo( a + 1, 3 ) + 1
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
df(j,k,l) = h * &
(f(j,k,l,i)* &
    ((x(j+1,k,l,b)-x(j,k+1,l+1,b))*(x(j,k+1,l,c)-x(j+1,k,l+1,c)-x(j,k,l+1,c)+x(j+1,k+1,l,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l+1,b))*(x(j,k,l+1,c)-x(j+1,k+1,l,c)-x(j+1,k,l,c)+x(j,k+1,l+1,c)) &
    +(x(j,k,l+1,b)-x(j+1,k+1,l,b))*(x(j+1,k,l,c)-x(j,k+1,l+1,c)-x(j,k+1,l,c)+x(j+1,k,l+1,c))) &
+f(j,k-1,l-1,i)* &
    ((x(j+1,k,l,b)-x(j,k-1,l-1,b))*(x(j,k-1,l,c)-x(j+1,k,l-1,c)-x(j,k,l-1,c)+x(j+1,k-1,l,c)) &
    +(x(j,k-1,l,b)-x(j+1,k,l-1,b))*(x(j,k,l-1,c)-x(j+1,k-1,l,c)-x(j+1,k,l,c)+x(j,k-1,l-1,c)) &
    +(x(j,k,l-1,b)-x(j+1,k-1,l,b))*(x(j+1,k,l,c)-x(j,k-1,l-1,c)-x(j,k-1,l,c)+x(j+1,k,l-1,c))) &
+f(j-1,k,l-1,i)* &
    ((x(j,k+1,l,b)-x(j-1,k,l-1,b))*(x(j,k,l-1,c)-x(j-1,k+1,l,c)-x(j-1,k,l,c)+x(j,k+1,l-1,c)) &
    +(x(j,k,l-1,b)-x(j-1,k+1,l,b))*(x(j-1,k,l,c)-x(j,k+1,l-1,c)-x(j,k+1,l,c)+x(j-1,k,l-1,c)) &
    +(x(j-1,k,l,b)-x(j,k+1,l-1,b))*(x(j,k+1,l,c)-x(j-1,k,l-1,c)-x(j,k,l-1,c)+x(j-1,k+1,l,c))) &
+f(j-1,k-1,l,i)* &
    ((x(j,k,l+1,b)-x(j-1,k-1,l,b))*(x(j-1,k,l,c)-x(j,k-1,l+1,c)-x(j,k-1,l,c)+x(j-1,k,l+1,c)) &
    +(x(j-1,k,l,b)-x(j,k-1,l+1,b))*(x(j,k-1,l,c)-x(j-1,k,l+1,c)-x(j,k,l+1,c)+x(j-1,k-1,l,c)) &
    +(x(j,k-1,l,b)-x(j-1,k,l+1,b))*(x(j,k,l+1,c)-x(j-1,k-1,l,c)-x(j-1,k,l,c)+x(j,k-1,l+1,c))) &
+f(j-1,k-1,l-1,i)* &
    ((x(j-1,k,l,b)-x(j,k-1,l-1,b))*(x(j-1,k,l-1,c)-x(j,k-1,l,c)-x(j-1,k-1,l,c)+x(j,k,l-1,c)) &
    +(x(j,k-1,l,b)-x(j-1,k,l-1,b))*(x(j-1,k-1,l,c)-x(j,k,l-1,c)-x(j,k-1,l-1,c)+x(j-1,k,l,c)) &
    +(x(j,k,l-1,b)-x(j-1,k-1,l,b))*(x(j,k-1,l-1,c)-x(j-1,k,l,c)-x(j-1,k,l-1,c)+x(j,k-1,l,c))) &
+f(j-1,k,l,i)* &
    ((x(j-1,k,l,b)-x(j,k+1,l+1,b))*(x(j-1,k,l+1,c)-x(j,k+1,l,c)-x(j-1,k+1,l,c)+x(j,k,l+1,c)) &
    +(x(j,k+1,l,b)-x(j-1,k,l+1,b))*(x(j-1,k+1,l,c)-x(j,k,l+1,c)-x(j,k+1,l+1,c)+x(j-1,k,l,c)) &
    +(x(j,k,l+1,b)-x(j-1,k+1,l,b))*(x(j,k+1,l+1,c)-x(j-1,k,l,c)-x(j-1,k,l+1,c)+x(j,k+1,l,c))) &
+f(j,k-1,l,i)* &
    ((x(j,k-1,l,b)-x(j+1,k,l+1,b))*(x(j+1,k-1,l,c)-x(j,k,l+1,c)-x(j,k-1,l+1,c)+x(j+1,k,l,c)) &
    +(x(j,k,l+1,b)-x(j+1,k-1,l,b))*(x(j,k-1,l+1,c)-x(j+1,k,l,c)-x(j+1,k,l+1,c)+x(j,k-1,l,c)) &
    +(x(j+1,k,l,b)-x(j,k-1,l+1,b))*(x(j+1,k,l+1,c)-x(j,k-1,l,c)-x(j+1,k-1,l,c)+x(j,k,l+1,c))) &
+f(j,k,l-1,i)* &
    ((x(j,k,l-1,b)-x(j+1,k+1,l,b))*(x(j,k+1,l-1,c)-x(j+1,k,l,c)-x(j+1,k,l-1,c)+x(j,k+1,l,c)) &
    +(x(j+1,k,l,b)-x(j,k+1,l-1,b))*(x(j+1,k,l-1,c)-x(j,k+1,l,c)-x(j+1,k+1,l,c)+x(j,k,l-1,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l-1,b))*(x(j+1,k+1,l,c)-x(j,k,l-1,c)-x(j,k+1,l-1,c)+x(j+1,k,l,c))))
end do
end do
end do

! General grid exact, flops: 57* 119+
case( 5 )
h = sign( 1.0 / 12.0, product( dx ) )
b = modulo( a, 3 ) + 1
c = modulo( a + 1, 3 ) + 1
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
df(j,k,l) = h * &
(f(j,k,l,i)* &
    ((x(j+1,k,l,b)-x(j,k+1,l+1,b))*(x(j,k+1,l,c)-x(j,k,l+1,c))+x(j+1,k,l,b)*(x(j+1,k+1,l,c)-x(j+1,k,l+1,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l+1,b))*(x(j,k,l+1,c)-x(j+1,k,l,c))+x(j,k+1,l,b)*(x(j,k+1,l+1,c)-x(j+1,k+1,l,c)) &
    +(x(j,k,l+1,b)-x(j+1,k+1,l,b))*(x(j+1,k,l,c)-x(j,k+1,l,c))+x(j,k,l+1,b)*(x(j+1,k,l+1,c)-x(j,k+1,l+1,c))) &
+f(j,k-1,l-1,i)* &
    ((x(j+1,k,l,b)-x(j,k-1,l-1,b))*(x(j,k-1,l,c)-x(j,k,l-1,c))+x(j+1,k,l,b)*(x(j+1,k-1,l,c)-x(j+1,k,l-1,c)) &
    +(x(j,k-1,l,b)-x(j+1,k,l-1,b))*(x(j,k,l-1,c)-x(j+1,k,l,c))+x(j,k-1,l,b)*(x(j,k-1,l-1,c)-x(j+1,k-1,l,c)) &
    +(x(j,k,l-1,b)-x(j+1,k-1,l,b))*(x(j+1,k,l,c)-x(j,k-1,l,c))+x(j,k,l-1,b)*(x(j+1,k,l-1,c)-x(j,k-1,l-1,c))) &
+f(j-1,k,l-1,i)* &
    ((x(j,k+1,l,b)-x(j-1,k,l-1,b))*(x(j,k,l-1,c)-x(j-1,k,l,c))+x(j,k+1,l,b)*(x(j,k+1,l-1,c)-x(j-1,k+1,l,c)) &
    +(x(j,k,l-1,b)-x(j-1,k+1,l,b))*(x(j-1,k,l,c)-x(j,k+1,l,c))+x(j,k,l-1,b)*(x(j-1,k,l-1,c)-x(j,k+1,l-1,c)) &
    +(x(j-1,k,l,b)-x(j,k+1,l-1,b))*(x(j,k+1,l,c)-x(j,k,l-1,c))+x(j-1,k,l,b)*(x(j-1,k+1,l,c)-x(j-1,k,l-1,c))) &
+f(j-1,k-1,l,i)* &
    ((x(j,k,l+1,b)-x(j-1,k-1,l,b))*(x(j-1,k,l,c)-x(j,k-1,l,c))+x(j,k,l+1,b)*(x(j-1,k,l+1,c)-x(j,k-1,l+1,c)) &
    +(x(j-1,k,l,b)-x(j,k-1,l+1,b))*(x(j,k-1,l,c)-x(j,k,l+1,c))+x(j-1,k,l,b)*(x(j-1,k-1,l,c)-x(j-1,k,l+1,c)) &
    +(x(j,k-1,l,b)-x(j-1,k,l+1,b))*(x(j,k,l+1,c)-x(j-1,k,l,c))+x(j,k-1,l,b)*(x(j,k-1,l+1,c)-x(j-1,k-1,l,c))) &
+f(j-1,k-1,l-1,i)* &
    ((x(j-1,k,l,b)-x(j,k-1,l-1,b))*(x(j,k,l-1,c)-x(j,k-1,l,c))+x(j-1,k,l,b)*(x(j-1,k,l-1,c)-x(j-1,k-1,l,c)) &
    +(x(j,k-1,l,b)-x(j-1,k,l-1,b))*(x(j-1,k,l,c)-x(j,k,l-1,c))+x(j,k-1,l,b)*(x(j-1,k-1,l,c)-x(j,k-1,l-1,c)) &
    +(x(j,k,l-1,b)-x(j-1,k-1,l,b))*(x(j,k-1,l,c)-x(j-1,k,l,c))+x(j,k,l-1,b)*(x(j,k-1,l-1,c)-x(j-1,k,l-1,c))) &
+f(j-1,k,l,i)* &
    ((x(j-1,k,l,b)-x(j,k+1,l+1,b))*(x(j,k,l+1,c)-x(j,k+1,l,c))+x(j-1,k,l,b)*(x(j-1,k,l+1,c)-x(j-1,k+1,l,c)) &
    +(x(j,k+1,l,b)-x(j-1,k,l+1,b))*(x(j-1,k,l,c)-x(j,k,l+1,c))+x(j,k+1,l,b)*(x(j-1,k+1,l,c)-x(j,k+1,l+1,c)) &
    +(x(j,k,l+1,b)-x(j-1,k+1,l,b))*(x(j,k+1,l,c)-x(j-1,k,l,c))+x(j,k,l+1,b)*(x(j,k+1,l+1,c)-x(j-1,k,l+1,c))) &
+f(j,k-1,l,i)* &
    ((x(j,k-1,l,b)-x(j+1,k,l+1,b))*(x(j+1,k,l,c)-x(j,k,l+1,c))+x(j,k-1,l,b)*(x(j+1,k-1,l,c)-x(j,k-1,l+1,c)) &
    +(x(j,k,l+1,b)-x(j+1,k-1,l,b))*(x(j,k-1,l,c)-x(j+1,k,l,c))+x(j,k,l+1,b)*(x(j,k-1,l+1,c)-x(j+1,k,l+1,c)) &
    +(x(j+1,k,l,b)-x(j,k-1,l+1,b))*(x(j,k,l+1,c)-x(j,k-1,l,c))+x(j+1,k,l,b)*(x(j+1,k,l+1,c)-x(j+1,k-1,l,c))) &
+f(j,k,l-1,i)* &
    ((x(j,k,l-1,b)-x(j+1,k+1,l,b))*(x(j,k+1,l,c)-x(j+1,k,l,c))+x(j,k,l-1,b)*(x(j,k+1,l-1,c)-x(j+1,k,l-1,c)) &
    +(x(j+1,k,l,b)-x(j,k+1,l-1,b))*(x(j,k,l-1,c)-x(j,k+1,l,c))+x(j+1,k,l,b)*(x(j+1,k,l-1,c)-x(j+1,k+1,l,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l-1,b))*(x(j+1,k,l,c)-x(j,k,l-1,c))+x(j,k+1,l,b)*(x(j+1,k+1,l,c)-x(j,k+1,l-1,c))))
end do
end do
end do

case default; stop 'illegal operator'

end select

end subroutine

end module

! Difference operator, node to cell
module m_diffnc
implicit none
contains

subroutine diffnc( df, f, i, a, i1, i2, oplevel, bb, x, dx1, dx2, dx3, dx )
real, intent(out) :: df(:,:,:)
real, intent(in) :: f(:,:,:,:), bb(:,:,:,:,:), x(:,:,:,:), &
    dx1(:), dx2(:), dx3(:), dx(3)
integer, intent(in) :: i, a, i1(3), i2(3), oplevel
real :: h
integer :: j, k, l, b, c

if ( any( i1 > i2 ) ) return

select case( oplevel )

! Saved B matrix, flops: 8* 7+
case( 6 )
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
    df(j,k,l) = &
      bb(j,k,l,1,a) * f(j+1,k+1,l+1,i) + f(j,k,l,i) * bb(j,k,l,5,a) &
    + bb(j,k,l,2,a) * f(j+1,k,l,i) + f(j,k+1,l+1,i) * bb(j,k,l,6,a) &
    + bb(j,k,l,3,a) * f(j,k+1,l,i) + f(j+1,k,l+1,i) * bb(j,k,l,7,a) &
    + bb(j,k,l,4,a) * f(j,k,l+1,i) + f(j+1,k+1,l,i) * bb(j,k,l,8,a)
end do
end do
end do

! Constant grid, flops: 1* 7+
case( 1 )
select case( a )
case( 1 )
    h = sign( 0.25 * dx(2) * dx(3), dx(1) )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * &
        ( f(j+1,k+1,l+1,i) - f(j,k,l,i) &
        + f(j+1,k,l,i) - f(j,k+1,l+1,i) &
        - f(j,k+1,l,i) + f(j+1,k,l+1,i) &
        - f(j,k,l+1,i) + f(j+1,k+1,l,i) )
    end do
    end do
    end do
case( 2 )
    h = sign( 0.25 * dx(3) * dx(1), dx(2) )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * &
        ( f(j+1,k+1,l+1,i) - f(j,k,l,i) &
        - f(j+1,k,l,i) + f(j,k+1,l+1,i) &
        + f(j,k+1,l,i) - f(j+1,k,l+1,i) &
        - f(j,k,l+1,i) + f(j+1,k+1,l,i) )
    end do
    end do
    end do
case( 3 )
    h = sign( 0.25 * dx(1) * dx(2), dx(3) )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * &
        ( f(j+1,k+1,l+1,i) - f(j,k,l,i) &
        - f(j+1,k,l,i) + f(j,k+1,l+1,i) &
        - f(j,k+1,l,i) + f(j+1,k,l+1,i) &
        + f(j,k,l+1,i) - f(j+1,k+1,l,i) )
    end do
    end do
    end do
end select
  
! Rectangular grid, flops: 2* 7+
case( 2 )
h = sign( 0.25, product( dx ) )
select case( a )
case( 1 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * dx2(k) * dx3(l) * &
        ( f(j+1,k+1,l+1,i) - f(j,k,l,i) &
        + f(j+1,k,l,i) - f(j,k+1,l+1,i) &
        - f(j,k+1,l,i) + f(j+1,k,l+1,i) &
        - f(j,k,l+1,i) + f(j+1,k+1,l,i) )
    end do
    end do
    end do
case( 2 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * dx3(l) * dx1(j) * &
        ( f(j+1,k+1,l+1,i) - f(j,k,l,i) &
        - f(j+1,k,l,i) + f(j,k+1,l+1,i) &
        + f(j,k+1,l,i) - f(j+1,k,l+1,i) &
        - f(j,k,l+1,i) + f(j+1,k+1,l,i) )
    end do
    end do
    end do
case( 3 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = h * dx1(j) * dx2(k) * &
        ( f(j+1,k+1,l+1,i) - f(j,k,l,i) &
        - f(j+1,k,l,i) + f(j,k+1,l+1,i) &
        - f(j,k+1,l,i) + f(j+1,k,l+1,i) &
        + f(j,k,l+1,i) - f(j+1,k+1,l,i) )
    end do
    end do
    end do
end select

! Parallelepiped grid, flops: 17* 27+
case( 3 )
h = sign( 0.25, product( dx ) )
b = modulo( a, 3 ) + 1
c = modulo( a + 1, 3 ) + 1
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
df(j,k,l) = h * &
((f(j+1,k+1,l+1,i)-f(j,k,l,i))* &
    (x(j,k+1,l+1,b)*(x(j+1,k,l+1,c)-x(j+1,k+1,l,c)) &
    +x(j+1,k,l+1,b)*(x(j+1,k+1,l,c)-x(j,k+1,l+1,c)) &
    +x(j+1,k+1,l,b)*(x(j,k+1,l+1,c)-x(j+1,k,l+1,c))) &
+(f(j+1,k,l,i)-f(j,k+1,l+1,i))* &
    (x(j,k,l,b)*(x(j+1,k+1,l,c)-x(j+1,k,l+1,c)) &
    +x(j+1,k,l+1,b)*(x(j,k,l,c)-x(j+1,k+1,l,c)) &
    +x(j+1,k+1,l,b)*(x(j+1,k,l+1,c)-x(j,k,l,c))) &
+(f(j,k+1,l,i)-f(j+1,k,l+1,i))* &
    (x(j,k,l,b)*(x(j,k+1,l+1,c)-x(j+1,k+1,l,c)) &
    +x(j+1,k+1,l,b)*(x(j,k,l,c)-x(j,k+1,l+1,c)) &
    +x(j,k+1,l+1,b)*(x(j+1,k+1,l,c)-x(j,k,l,c))) &
+(f(j,k,l+1,i)-f(j+1,k+1,l,i))* &
    (x(j,k,l,b)*(x(j+1,k,l+1,c)-x(j,k+1,l+1,c)) &
    +x(j,k+1,l+1,b)*(x(j,k,l,c)-x(j+1,k,l+1,c)) &
    +x(j+1,k,l+1,b)*(x(j,k+1,l+1,c)-x(j,k,l,c))))
end do
end do
end do

! General grid one-point quadrature, flops: 17* 63+
case( 4 )
h = sign( 0.0625, product( dx ) )
b = modulo( a, 3 ) + 1
c = modulo( a + 1, 3 ) + 1
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
df(j,k,l) = h * &
((f(j+1,k+1,l+1,i)-f(j,k,l,i))* &
    ((x(j+1,k,l,b)-x(j,k+1,l+1,b))*(x(j,k+1,l,c)-x(j+1,k,l+1,c)-x(j,k,l+1,c)+x(j+1,k+1,l,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l+1,b))*(x(j,k,l+1,c)-x(j+1,k+1,l,c)-x(j+1,k,l,c)+x(j,k+1,l+1,c)) &
    +(x(j,k,l+1,b)-x(j+1,k+1,l,b))*(x(j+1,k,l,c)-x(j,k+1,l+1,c)-x(j,k+1,l,c)+x(j+1,k,l+1,c))) &
+(f(j+1,k,l,i)-f(j,k+1,l+1,i))* &
    ((x(j+1,k+1,l+1,b)-x(j,k,l,b))*(x(j,k,l+1,c)-x(j+1,k+1,l,c)-x(j,k+1,l,c)+x(j+1,k,l+1,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l+1,b))*(x(j+1,k+1,l+1,c)-x(j,k,l,c)-x(j,k,l+1,c)+x(j+1,k+1,l,c)) &
    +(x(j,k,l+1,b)-x(j+1,k+1,l,b))*(x(j,k+1,l,c)-x(j+1,k,l+1,c)-x(j+1,k+1,l+1,c)+x(j,k,l,c))) &
+(f(j,k+1,l,i)-f(j+1,k,l+1,i))* &
    ((x(j+1,k+1,l+1,b)-x(j,k,l,b))*(x(j+1,k,l,c)-x(j,k+1,l+1,c)-x(j,k,l+1,c)+x(j+1,k+1,l,c)) &
    +(x(j,k,l+1,b)-x(j+1,k+1,l,b))*(x(j+1,k+1,l+1,c)-x(j,k,l,c)-x(j+1,k,l,c)+x(j,k+1,l+1,c)) &
    +(x(j+1,k,l,b)-x(j,k+1,l+1,b))*(x(j,k,l+1,c)-x(j+1,k+1,l,c)-x(j+1,k+1,l+1,c)+x(j,k,l,c))) &
+(f(j,k,l+1,i)-f(j+1,k+1,l,i))* &
    ((x(j+1,k+1,l+1,b)-x(j,k,l,b))*(x(j,k+1,l,c)-x(j+1,k,l+1,c)-x(j+1,k,l,c)+x(j,k+1,l+1,c)) &
    +(x(j+1,k,l,b)-x(j,k+1,l+1,b))*(x(j+1,k+1,l+1,c)-x(j,k,l,c)-x(j,k+1,l,c)+x(j+1,k,l+1,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l+1,b))*(x(j+1,k,l,c)-x(j,k+1,l+1,c)-x(j+1,k+1,l+1,c)+x(j,k,l,c))))
end do
end do
end do

! General grid exact, flops: 57* 119+
case( 5 )
h = sign( 1.0 / 12.0, product( dx ) )
b = modulo( a, 3 ) + 1
c = modulo( a + 1, 3 ) + 1
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
df(j,k,l) = h * &
(f(j+1,k+1,l+1,i)* &
    ((x(j+1,k,l,b)-x(j,k+1,l+1,b))*(x(j+1,k+1,l,c)-x(j+1,k,l+1,c))+x(j,k+1,l+1,b)*(x(j,k,l+1,c)-x(j,k+1,l,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l+1,b))*(x(j,k+1,l+1,c)-x(j+1,k+1,l,c))+x(j+1,k,l+1,b)*(x(j+1,k,l,c)-x(j,k,l+1,c)) &
    +(x(j,k,l+1,b)-x(j+1,k+1,l,b))*(x(j+1,k,l+1,c)-x(j,k+1,l+1,c))+x(j+1,k+1,l,b)*(x(j,k+1,l,c)-x(j+1,k,l,c))) &
+f(j+1,k,l,i)* &
    ((x(j+1,k+1,l+1,b)-x(j,k,l,b))*(x(j+1,k,l+1,c)-x(j+1,k+1,l,c))+x(j,k,l,b)*(x(j,k+1,l,c)-x(j,k,l+1,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l+1,b))*(x(j+1,k+1,l,c)-x(j,k,l,c))+x(j+1,k,l+1,b)*(x(j,k,l+1,c)-x(j+1,k+1,l+1,c)) &
    +(x(j,k,l+1,b)-x(j+1,k+1,l,b))*(x(j,k,l,c)-x(j+1,k,l+1,c))+x(j+1,k+1,l,b)*(x(j+1,k+1,l+1,c)-x(j,k+1,l,c))) &
+f(j,k+1,l,i)* &
    ((x(j+1,k+1,l+1,b)-x(j,k,l,b))*(x(j+1,k+1,l,c)-x(j,k+1,l+1,c))+x(j,k,l,b)*(x(j,k,l+1,c)-x(j+1,k,l,c)) &
    +(x(j+1,k,l,b)-x(j,k+1,l+1,b))*(x(j,k,l,c)-x(j+1,k+1,l,c))+x(j,k+1,l+1,b)*(x(j+1,k+1,l+1,c)-x(j,k,l+1,c)) &
    +(x(j,k,l+1,b)-x(j+1,k+1,l,b))*(x(j,k+1,l+1,c)-x(j,k,l,c))+x(j+1,k+1,l,b)*(x(j+1,k,l,c)-x(j+1,k+1,l+1,c))) &
+f(j,k,l+1,i)* &
    ((x(j+1,k+1,l+1,b)-x(j,k,l,b))*(x(j,k+1,l+1,c)-x(j+1,k,l+1,c))+x(j,k,l,b)*(x(j+1,k,l,c)-x(j,k+1,l,c)) &
    +(x(j+1,k,l,b)-x(j,k+1,l+1,b))*(x(j+1,k,l+1,c)-x(j,k,l,c))+x(j,k+1,l+1,b)*(x(j,k+1,l,c)-x(j+1,k+1,l+1,c)) &
    +(x(j,k+1,l,b)-x(j+1,k,l+1,b))*(x(j,k,l,c)-x(j,k+1,l+1,c))+x(j+1,k,l+1,b)*(x(j+1,k+1,l+1,c)-x(j+1,k,l,c))) &
+f(j,k,l,i)* &
    ((x(j,k+1,l+1,b)-x(j+1,k,l,b))*(x(j,k+1,l,c)-x(j,k,l+1,c))+x(j+1,k,l,b)*(x(j+1,k,l+1,c)-x(j+1,k+1,l,c)) &
    +(x(j+1,k,l+1,b)-x(j,k+1,l,b))*(x(j,k,l+1,c)-x(j+1,k,l,c))+x(j,k+1,l,b)*(x(j+1,k+1,l,c)-x(j,k+1,l+1,c)) &
    +(x(j+1,k+1,l,b)-x(j,k,l+1,b))*(x(j+1,k,l,c)-x(j,k+1,l,c))+x(j,k,l+1,b)*(x(j,k+1,l+1,c)-x(j+1,k,l+1,c))) &
+f(j,k+1,l+1,i)* &
    ((x(j,k,l,b)-x(j+1,k+1,l+1,b))*(x(j,k,l+1,c)-x(j,k+1,l,c))+x(j+1,k+1,l+1,b)*(x(j+1,k+1,l,c)-x(j+1,k,l+1,c)) &
    +(x(j+1,k,l+1,b)-x(j,k+1,l,b))*(x(j+1,k+1,l+1,c)-x(j,k,l+1,c))+x(j,k+1,l,b)*(x(j,k,l,c)-x(j+1,k+1,l,c)) &
    +(x(j+1,k+1,l,b)-x(j,k,l+1,b))*(x(j,k+1,l,c)-x(j+1,k+1,l+1,c))+x(j,k,l+1,b)*(x(j+1,k,l+1,c)-x(j,k,l,c))) &
+f(j+1,k,l+1,i)* &
    ((x(j,k,l,b)-x(j+1,k+1,l+1,b))*(x(j+1,k,l,c)-x(j,k,l+1,c))+x(j+1,k+1,l+1,b)*(x(j,k+1,l+1,c)-x(j+1,k+1,l,c)) &
    +(x(j,k+1,l+1,b)-x(j+1,k,l,b))*(x(j,k,l+1,c)-x(j+1,k+1,l+1,c))+x(j+1,k,l,b)*(x(j+1,k+1,l,c)-x(j,k,l,c)) &
    +(x(j+1,k+1,l,b)-x(j,k,l+1,b))*(x(j+1,k+1,l+1,c)-x(j+1,k,l,c))+x(j,k,l+1,b)*(x(j,k,l,c)-x(j,k+1,l+1,c))) &
+f(j+1,k+1,l,i)* &
    ((x(j,k,l,b)-x(j+1,k+1,l+1,b))*(x(j,k+1,l,c)-x(j+1,k,l,c))+x(j+1,k+1,l+1,b)*(x(j+1,k,l+1,c)-x(j,k+1,l+1,c)) &
    +(x(j,k+1,l+1,b)-x(j+1,k,l,b))*(x(j+1,k+1,l+1,c)-x(j,k+1,l,c))+x(j+1,k,l,b)*(x(j,k,l,c)-x(j+1,k,l+1,c)) &
    +(x(j+1,k,l+1,b)-x(j,k+1,l,b))*(x(j+1,k,l,c)-x(j+1,k+1,l+1,c))+x(j,k+1,l,b)*(x(j,k+1,l+1,c)-x(j,k,l,c))))
end do
end do
end do

case default; stop 'illegal operator'

end select

end subroutine

end module

! Hourglass corrections
module m_hourglass
implicit none
contains

! Node to cell
subroutine hourglassnc( df, f, iq, i, i1, i2 )
real, intent(out) :: df(:,:,:)
real, intent(in) :: f(:,:,:,:)
integer, intent(in) :: iq, i, i1(3), i2(3)
integer :: j, k, l

if ( any( i1 > i2 ) ) return

select case( iq )
case( 1 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = &
          f(j,k,l,i) + f(j+1,k+1,l+1,i) &
        + f(j,k+1,l+1,i) + f(j+1,k,l,i) &
        - f(j+1,k,l+1,i) - f(j,k+1,l,i) &
        - f(j+1,k+1,l,i) - f(j,k,l+1,i)
    end do
    end do
    end do
case( 2 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = &
          f(j,k,l,i) + f(j+1,k+1,l+1,i) &
        - f(j,k+1,l+1,i) - f(j+1,k,l,i) &
        + f(j+1,k,l+1,i) + f(j,k+1,l,i) &
        - f(j+1,k+1,l,i) - f(j,k,l+1,i)
    end do
    end do
    end do
case( 3 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = &
          f(j,k,l,i) + f(j+1,k+1,l+1,i) &
        - f(j,k+1,l+1,i) - f(j+1,k,l,i) &
        - f(j+1,k,l+1,i) - f(j,k+1,l,i) &
        + f(j+1,k+1,l,i) + f(j,k,l+1,i)
    end do
    end do
    end do
case( 4 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = &
          f(j,k,l,i) - f(j+1,k+1,l+1,i) &
        + f(j,k+1,l+1,i) - f(j+1,k,l,i) &
        + f(j+1,k,l+1,i) - f(j,k+1,l,i) &
        + f(j+1,k+1,l,i) - f(j,k,l+1,i) 
    end do
    end do
    end do
end select

end subroutine

!------------------------------------------------------------------------------!

! Cell to node
subroutine hourglasscn( df, f, iq, i1, i2 )
real, intent(out) :: df(:,:,:)
real, intent(in) :: f(:,:,:)
integer, intent(in) :: iq, i1(3), i2(3)
integer :: j, k, l

if ( any( i1 > i2 ) ) return

select case( iq )
case( 1 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = &
          f(j,k,l) + f(j-1,k-1,l-1) &
        + f(j,k-1,l-1) + f(j-1,k,l) &
        - f(j-1,k,l-1) - f(j,k-1,l) &
        - f(j-1,k-1,l) - f(j,k,l-1)
    end do
    end do
    end do
case( 2 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = &
          f(j,k,l) + f(j-1,k-1,l-1) &
        - f(j,k-1,l-1) - f(j-1,k,l) &
        + f(j-1,k,l-1) + f(j,k-1,l) &
        - f(j-1,k-1,l) - f(j,k,l-1)
    end do
    end do
    end do
case( 3 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = &
          f(j,k,l) + f(j-1,k-1,l-1) &
        - f(j,k-1,l-1) - f(j-1,k,l) &
        - f(j-1,k,l-1) - f(j,k-1,l) &
        + f(j-1,k-1,l) + f(j,k,l-1)
    end do
    end do
    end do
case( 4 )
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        df(j,k,l) = &
          f(j,k,l) - f(j-1,k-1,l-1) &
        + f(j,k-1,l-1) - f(j-1,k,l) &
        + f(j-1,k,l-1) - f(j,k-1,l) &
        + f(j-1,k-1,l) - f(j,k,l-1)
    end do
    end do
    end do
end select

end subroutine

end module

! Boundary conditions
module m_bc
implicit none
contains

! Scalar field
subroutine scalar_bc( f, bc1, bc2, i1, i2 )
real, intent(inout) :: f(:,:,:)
integer, intent(in) :: bc1(3), bc2(3), i1(3), i2(3)
integer :: b1(3), b2(3), nm(3), j1, k1, l1, j2, k2, l2
nm = (/ size(f,1), size(f,2), size(f,3) /)
j1 = i1(1); j2 = i2(1)
k1 = i1(2); k2 = i2(2)
l1 = i1(3); l2 = i2(3)
b1 = abs( mod( bc1, 10 ) )
b2 = abs( mod( bc2, 10 ) )
where ( b1 == 4 ) b1 = 2
where ( b2 == 4 ) b2 = 2
where ( nm == 1 .or. i1 <  1 .or. i1 >= nm ) b1 = 99
where ( nm == 1 .or. i2 <= 1 .or. i2 >  nm ) b2 = 99
if ( b1(1) == 2 ) f(j1,:,:) = f(j1+1,:,:)
if ( b1(2) == 2 ) f(:,k1,:) = f(:,k1+1,:)
if ( b1(3) == 2 ) f(:,:,l1) = f(:,:,l1+1)
if ( b2(1) == 2 ) f(j2,:,:) = f(j2-1,:,:)
if ( b2(2) == 2 ) f(:,k2,:) = f(:,k2-1,:)
if ( b2(3) == 2 ) f(:,:,l2) = f(:,:,l2-1)
end subroutine

! Vector field
subroutine vector_bc( f, bc1, bc2, i1, i2 )
implicit none
real, intent(inout) :: f(:,:,:,:)
integer, intent(in) :: bc1(3), bc2(3), i1(3), i2(3)
integer :: nm(3), b1(3), b2(3), s1(3), s2(3), j1, k1, l1, j2, k2, l2
nm = (/ size(f,1), size(f,2), size(f,3) /)
j1 = i1(1); j2 = i2(1)
k1 = i1(2); k2 = i2(2)
l1 = i1(3); l2 = i2(3)
b1 = mod( bc1, 10 )
b2 = mod( bc2, 10 )
where ( nm == 1 .or. i1 < 1 .or. i1 > nm ) b1 = 99
where ( nm == 1 .or. i2 < 1 .or. i2 > nm ) b2 = 99

! Anti-mirror symmetry at the node
if ( b1(1) == -1 ) then; f(j1,:,:,2) = 0.0; f(j1,:,:,3) = 0.0; end if
if ( b1(2) == -1 ) then; f(:,k1,:,3) = 0.0; f(:,k1,:,1) = 0.0; end if
if ( b1(3) == -1 ) then; f(:,:,l1,1) = 0.0; f(:,:,l1,2) = 0.0; end if
if ( b2(1) == -1 ) then; f(j2,:,:,2) = 0.0; f(j2,:,:,3) = 0.0; end if
if ( b2(2) == -1 ) then; f(:,k2,:,3) = 0.0; f(:,k2,:,1) = 0.0; end if
if ( b2(3) == -1 ) then; f(:,:,l2,1) = 0.0; f(:,:,l2,2) = 0.0; end if

! Mirror symmetry at the node
if ( b1(1) == 1 ) f(j1,:,:,1) = 0.0
if ( b1(2) == 1 ) f(:,k1,:,2) = 0.0
if ( b1(3) == 1 ) f(:,:,l1,3) = 0.0
if ( b2(1) == 1 ) f(j2,:,:,1) = 0.0
if ( b2(2) == 1 ) f(:,k2,:,2) = 0.0
if ( b2(3) == 1 ) f(:,:,l2,3) = 0.0

! Rigid
if ( b1(1) == 3 ) f(j1,:,:,:) = 0.0
if ( b1(2) == 3 ) f(:,k1,:,:) = 0.0
if ( b1(3) == 3 ) f(:,:,l1,:) = 0.0
if ( b2(1) == 3 ) f(j2,:,:,:) = 0.0
if ( b2(2) == 3 ) f(:,k2,:,:) = 0.0
if ( b2(3) == 3 ) f(:,:,l2,:) = 0.0

where ( i1 >= nm ) b1 = 99
where ( i2 <= 1  ) b2 = 99

! Continue
if ( b1(1) == 4 ) f(j1,:,:,:) = f(j1+1,:,:,:)
if ( b1(2) == 4 ) f(:,k1,:,:) = f(:,k1+1,:,:)
if ( b1(3) == 4 ) f(:,:,l1,:) = f(:,:,l1+1,:)
if ( b2(1) == 4 ) f(j2,:,:,:) = f(j2-1,:,:,:)
if ( b2(2) == 4 ) f(:,k2,:,:) = f(:,k2-1,:,:)
if ( b2(3) == 4 ) f(:,:,l2,:) = f(:,:,l2-1,:)

! Symmetry at the cell
b1 = abs( b1 )
b2 = abs( b2 )
s1 = sign( 1, bc1 )
s2 = sign( 1, bc2 )
if ( b1(1) == 2 ) then
    f(j1,:,:,1) = -s1(1) * f(j1+1,:,:,1)
    f(j1,:,:,2) =  s1(1) * f(j1+1,:,:,2)
    f(j1,:,:,3) =  s1(1) * f(j1+1,:,:,3)
end if
if ( b1(2) == 2 ) then
    f(:,k1,:,1) =  s1(2) * f(:,k1+1,:,1)
    f(:,k1,:,2) = -s1(2) * f(:,k1+1,:,2)
    f(:,k1,:,3) =  s1(2) * f(:,k1+1,:,3)
end if 
if ( b1(3) == 2 ) then
    f(:,:,l1,1) =  s1(3) * f(:,:,l1+1,1)
    f(:,:,l1,2) =  s1(3) * f(:,:,l1+1,2)
    f(:,:,l1,3) = -s1(3) * f(:,:,l1+1,3)
end if
if ( b2(1) == 2 ) then
    f(j2,:,:,1) = -s2(1) * f(j2-1,:,:,1)
    f(j2,:,:,2) =  s2(1) * f(j2-1,:,:,2)
    f(j2,:,:,3) =  s2(1) * f(j2-1,:,:,3)
end if
if ( b2(2) == 2 ) then 
    f(:,k2,:,1) =  s2(2) * f(:,k2-1,:,1)
    f(:,k2,:,2) = -s2(2) * f(:,k2-1,:,2)
    f(:,k2,:,3) =  s2(2) * f(:,k2-1,:,3)
end if
if ( b2(3) == 2 ) then
    f(:,:,l2,1) =  s2(3) * f(:,:,l2-1,1)
    f(:,:,l2,2) =  s2(3) * f(:,:,l2-1,2)
    f(:,:,l2,3) = -s2(3) * f(:,:,l2-1,3)
end if

end subroutine

end module

! Find surface normals
module m_surfnormals
implicit none
contains

subroutine surfnormals( nhat, x, dx, i1, i2, ihat )
real, intent(out) :: nhat(:,:,:,:)
real, intent(in) :: x(:,:,:,:), dx(3)
integer, intent(in) :: i1(3), i2(3), ihat
integer :: j, k, l, a, b, c
real :: h

nhat = 0.0
h = sign( 1.0 / 12.0, product( dx ) )

do a = 1, 3
    b = modulo( a,   3 ) + 1
    c = modulo( a+1, 3 ) + 1
    select case( ihat )
    case( 1 )
        j = i1(1)
        do l = i1(3), i2(3)
        do k = i1(2), i2(2)
            nhat(1,k,l,a) = h * &
            ( x(j,k+1,l,b) * ( x(j,k,l+1,c) + x(j,k+1,l+1,c)   &
                             - x(j,k,l-1,c) - x(j,k+1,l-1,c) ) &
            + x(j,k-1,l,b) * ( x(j,k,l-1,c) + x(j,k-1,l-1,c)   &
                             - x(j,k,l+1,c) - x(j,k-1,l+1,c) ) &
            + x(j,k,l+1,b) * ( x(j,k-1,l,c) + x(j,k-1,l+1,c)   &
                             - x(j,k+1,l,c) - x(j,k+1,l+1,c) ) &
            + x(j,k,l-1,b) * ( x(j,k+1,l,c) + x(j,k+1,l-1,c)   &
                             - x(j,k-1,l,c) - x(j,k-1,l-1,c) ) &
            + x(j,k+1,l+1,b) * ( x(j,k,l+1,c) - x(j,k+1,l,c) ) &
            + x(j,k-1,l-1,b) * ( x(j,k,l-1,c) - x(j,k-1,l,c) ) &
            + x(j,k-1,l+1,b) * ( x(j,k-1,l,c) - x(j,k,l+1,c) ) &
            + x(j,k+1,l-1,b) * ( x(j,k+1,l,c) - x(j,k,l-1,c) ) )
        end do
        end do
    case( 2 )
        k = i1(2)
        do l = i1(3), i2(3)
        do j = i1(1), i2(1)
            nhat(j,1,l,a) = h * &
            ( x(j,k,l+1,b) * ( x(j+1,k,l,c) + x(j+1,k,l+1,c)   &
                             - x(j-1,k,l,c) - x(j-1,k,l+1,c) ) &
            + x(j,k,l-1,b) * ( x(j-1,k,l,c) + x(j-1,k,l-1,c)   &
                             - x(j+1,k,l,c) - x(j+1,k,l-1,c) ) &
            + x(j+1,k,l,b) * ( x(j,k,l-1,c) + x(j+1,k,l-1,c)   &
                             - x(j,k,l+1,c) - x(j+1,k,l+1,c) ) &
            + x(j-1,k,l,b) * ( x(j,k,l+1,c) + x(j-1,k,l+1,c)   &
                             - x(j,k,l-1,c) - x(j-1,k,l-1,c) ) &
            + x(j+1,k,l+1,b) * ( x(j+1,k,l,c) - x(j,k,l+1,c) ) &
            + x(j-1,k,l-1,b) * ( x(j-1,k,l,c) - x(j,k,l-1,c) ) &
            + x(j+1,k,l-1,b) * ( x(j,k,l-1,c) - x(j+1,k,l,c) ) &
            + x(j-1,k,l+1,b) * ( x(j,k,l+1,c) - x(j-1,k,l,c) ) )
        end do
        end do
    case( 3 )
        l = i1(3)
        do k = i1(2), i2(2)
        do j = i1(1), i2(1)
            nhat(j,k,1,a) = h * &
            ( x(j+1,k,l,b) * ( x(j,k+1,l,c) + x(j+1,k+1,l,c)   &
                             - x(j,k-1,l,c) - x(j+1,k-1,l,c) ) &
            + x(j-1,k,l,b) * ( x(j,k-1,l,c) + x(j-1,k-1,l,c)   &
                             - x(j,k+1,l,c) - x(j-1,k+1,l,c) ) &
            + x(j,k+1,l,b) * ( x(j-1,k,l,c) + x(j-1,k+1,l,c)   &
                             - x(j+1,k,l,c) - x(j+1,k+1,l,c) ) &
            + x(j,k-1,l,b) * ( x(j+1,k,l,c) + x(j+1,k-1,l,c)   &
                             - x(j-1,k,l,c) - x(j-1,k-1,l,c) ) &
            + x(j+1,k+1,l,b) * ( x(j,k+1,l,c) - x(j+1,k,l,c) ) &
            + x(j-1,k-1,l,b) * ( x(j,k-1,l,c) - x(j-1,k,l,c) ) &
            + x(j-1,k+1,l,b) * ( x(j-1,k,l,c) - x(j,k+1,l,c) ) &
            + x(j+1,k-1,l,b) * ( x(j+1,k,l,c) - x(j,k-1,l,c) ) )
        end do
        end do
    case default; stop 'error: surfnormal'
    end select
end do

end subroutine

end module

! Miscellaneous utilities
module m_util
implicit none
contains

! Array reciprocal
subroutine invert( f )
real, intent(inout) :: f(:,:,:)
integer :: n(3), j, k, l
n = (/ size(f,1), size(f,2), size(f,3) /)
do l = 1, n(3)
do k = 1, n(2)
do j = 1, n(1)
    if ( f(j,k,l) /= 0.0 ) f(j,k,l) = 1.0 / f(j,k,l)
end do
end do
end do
end subroutine

! Squared distance to x0
subroutine radius( r, x, x0, i1, i2 )
real, intent(out) :: r(:,:,:)
real, intent(in) :: x(:,:,:,:), x0(3)
integer, intent(in) :: i1(3), i2(3)
integer :: n(3), j, k, l
n = (/ size(r,1), size(r,2), size(r,3) /)
if ( any( i1 < 1 .or. i2 > n ) ) stop 'error in radius'
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
    r(j,k,l) = &
    ( x(j,k,l,1) - x0(1) ) * ( x(j,k,l,1) - x0(1) ) + &
    ( x(j,k,l,2) - x0(2) ) * ( x(j,k,l,2) - x0(2) ) + &
    ( x(j,k,l,3) - x0(3) ) * ( x(j,k,l,3) - x0(3) )
end do
end do
end do
end subroutine

! Average of local eight values
subroutine average( f2, f1, i1, i2, d )
real, intent(out) :: f2(:,:,:)
real, intent(in) :: f1(:,:,:)
integer, intent(in) :: i1(3), i2(3), d
integer :: n(3), j, k, l
n = (/ size(f1,1), size(f1,2), size(f1,3) /)
if ( any( i1 < 1 .or. i2 > n ) ) stop 'error in average'
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
    f2(j,k,l) = 0.125 * &
    ( f1(j,k,l) + f1(j+d,k+d,l+d) &
    + f1(j,k+d,l+d) + f1(j+d,k,l) &
    + f1(j+d,k,l+d) + f1(j,k+d,l) &
    + f1(j+d,k+d,l) + f1(j,k,l+d) )
end do
end do
end do
call set_halo( f2, 0.0, i1, i2 )
end subroutine

! Set array to real value outside specified region
subroutine set_halo( f, r, i1, i2 )
real, intent(inout) :: f(:,:,:)
real, intent(in) :: r
integer, intent(in) :: i1(3), i2(3)
integer :: n(3), i3(3), i4(3)
n = (/ size(f,1), size(f,2), size(f,3) /)
i3 = min( i1, n + 1 )
i4 = max( i2, 0 )
if ( n(1) > 1 ) f(:i3(1)-1,:,:) = r
if ( n(2) > 1 ) f(:,:i3(2)-1,:) = r
if ( n(3) > 1 ) f(:,:,:i3(3)-1) = r
if ( n(1) > 1 ) f(i4(1)+1:,:,:) = r
if ( n(2) > 1 ) f(:,i4(2)+1:,:) = r
if ( n(3) > 1 ) f(:,:,i4(3)+1:) = r
end subroutine

! L2 vector norm
subroutine vector_norm( f, w, i1, i2, di )
real, intent(out) :: f(:,:,:)
real, intent(in) :: w(:,:,:,:)
integer, intent(in) :: i1(3), i2(3), di(3)
integer :: n(3), j, k, l
n = (/ size(f,1), size(f,2), size(f,3) /)
if ( any( i1 < 1 .or. i2 > n ) ) stop 'error in vector_norm'
do l = i1(3), i2(3), di(3)
do k = i1(2), i2(2), di(2)
do j = i1(1), i2(1), di(1)
    f(j,k,l) = &
    w(j,k,l,1) * w(j,k,l,1) + &
    w(j,k,l,2) * w(j,k,l,2) + &
    w(j,k,l,3) * w(j,k,l,3)
end do
end do
end do
end subroutine

! Frobenius tensor norm - much faster than L2 norm for tensors
subroutine tensor_norm( f, w1, w2, i1, i2, di )
real, intent(out) :: f(:,:,:)
real, intent(in) :: w1(:,:,:,:), w2(:,:,:,:)
integer, intent(in) :: i1(3), i2(3), di(3)
integer :: n(3), j, k, l
n = (/ size(f,1), size(f,2), size(f,3) /)
if ( any( i1 < 1 .or. i2 > n ) ) stop 'error in tensor_norm'
do l = i1(3), i2(3), di(3)
do k = i1(2), i2(2), di(2)
do j = i1(1), i2(1), di(1)
    f(j,k,l) = &
    w1(j,k,l,1) * w1(j,k,l,1) + &
    w1(j,k,l,2) * w1(j,k,l,2) + &
    w1(j,k,l,3) * w1(j,k,l,3) + &
    ( w2(j,k,l,1) * w2(j,k,l,1) &
    + w2(j,k,l,2) * w2(j,k,l,2) &
    + w2(j,k,l,3) * w2(j,k,l,3) ) * 2.
end do
end do
end do
end subroutine

! In-place linear interpolation 
subroutine interpolate( f, i3, i4, di )
real, intent(inout) :: f(:,:,:)
integer, intent(in) :: i3(3), i4(3), di(3)
integer :: i1(3), i2(3), n(3), i, j, k, l, d
real :: h1, h2
n = (/ size(f,1), size(f,2), size(f,3) /)
i1 = i3
i2 = i4
where( i1 < 1 ) i1 = i1 + (-i1 / di + 1) * di
where( i2 > n ) i2 = i1 + (n - i1) / di * di
d = di(1)
do i = 1, d - 1
    h1 = 1.0 / d * i
    h2 = 1.0 / d * ( d - i )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1) - d, d
        f(j+i,k,l) = h1 * f(j,k,l) + h2 * f(j+d,k,l)
    end do
    end do
    end do
end do
d = di(2)
do i = 1, d - 1
    h1 = 1.0 / d * i
    h2 = 1.0 / d * ( d - i )
    do l = i1(3), i2(3), di(1)
    do k = i1(2), i2(2) - d, d
    do j = i1(1), i2(1)
        f(j,k+i,l) = h1 * f(j,k,l) + h2 * f(j,k+d,l)
    end do
    end do
    end do
end do
d = di(3)
do i = 1, d - 1
    h1 = 1.0 / d * i
    h2 = 1.0 / d * ( d - i )
    do l = i1(3), i2(3) - d, d
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        f(j,k,l+i) = h1 * f(j,k,l) + h2 * f(j,k,l+d)
    end do
    end do
    end do
end do
end subroutine

! Time function
real function time_function( tfunc, tm, dt, period )
character(*), intent(in) :: tfunc
real, intent(in) :: tm, dt, period
real, parameter :: pi = 3.14159265
real :: t
time_function = 0.0
select case( tfunc )
case( 'const'  )
    time_function = 1.0
case( 'delta'  )
    if ( abs( tm ) < 0.25 * dt ) time_function = 1.0
case( 'brune' )
    time_function = -exp( -tm / period ) / period * (tm + period) + 1.0
case( 'dbrune' )
    time_function =  exp( -tm / period ) / period ** 2.0 * tm
case( 'ddbrune' )
    time_function = -exp( -tm / period ) / period ** 3.0 * (tm - period) 
case( 'gaussian' )
    t = ( tm - 4.0 * period ) / period
    time_function = exp( -0.5 * t * t ) / ( period * sqrt( 2.0 * pi ) )
case( 'dgaussian', 'ricker1' )
    t = tm - period
    time_function = t * exp( -2.0 * (pi * t / period) ** 2.0 )
case( 'ddgaussian', 'ricker2' )
    t = ( pi * (tm - period) / period ) ** 2.0
    time_function = (1.0 - 2.0 * t) * exp( -t )
case default
    write( 0, * ) 'invalid time func: ', trim( tfunc )
    stop
end select
end function

! Timer
real function timer( i )
integer, intent(in) :: i
integer, save :: clock0, clockrate, clockmax
integer(8), save :: timers(8)
integer :: clock1
if ( i == 0 ) then
    call system_clock( clock0, clockrate, clockmax )
    timer = 0
    timers = 0
else
    call system_clock( clock1 )
    timers = timers + clock1 - clock0
    if ( clock0 > clock1 ) timers = timers + clockmax
    clock0 = clock1
    timer = real( timers(i) ) / real( clockrate )
    timers(:i) = 0
end if
end function

end module

! Fortran real binary I/O
module m_frio
integer, parameter :: frio_file_null = -1
contains

subroutine frio2( fh, f, mode, filename, m, o, verb )
implicit none
integer, intent(inout) :: fh
real, intent(inout) :: f(:,:)
character(1), intent(in) :: mode
character(*), intent(in) :: filename
integer, intent(in) :: m, o
logical, intent(in) :: verb
integer, save :: filehandle = 10
integer :: i, n
if ( fh == frio_file_null ) then
    filehandle = filehandle + 1
    fh = filehandle
    if ( verb ) write( 0, * ) 'Opening file: ', trim( filename )
    inquire( iolength=i ) f(:,1)
    if ( mode == 'r' .or. o > 0 ) then
        open( fh, file=filename, recl=i, form='unformatted', access='direct', &
        status='old' )
    else
        open( fh, file=filename, recl=i, form='unformatted', access='direct', &
        status='new' )
    end if
end if
if ( verb ) write( 0, * ) 'Writing file: ', trim( filename )
n = size( f, 2 )
if ( mode == 'r' ) then
    do i = 1, n
        read( fh, rec=o+i ) f(:,i)
    end do
else
    do i = 1, n
        write( fh, rec=o+i ) f(:,i)
    end do
end if
if ( o+n == m ) then
    close( fh )
    if ( fh == filehandle ) filehandle = filehandle - 1
    fh = frio_file_null
end if
end subroutine

end module

! Collective routines - serial version
module m_collective
use m_frio
implicit none
integer, parameter :: file_null = frio_file_null
contains

! Initialize
subroutine initialize( np0, ip, master )
integer, intent(out) :: np0, ip
logical, intent(out) :: master
np0 = 1
ip = 0
master = .true.
end subroutine

! Finalize
subroutine finalize
end subroutine

! Process rank
subroutine rank( ip3, ipid, np3 )
integer, intent(out) :: ip3(3), ipid
integer, intent(in) :: np3(3)
ip3 = np3
ip3 = 0
ipid = 0
end subroutine

! Set root process
subroutine setroot( ip3root )
integer, intent(in) :: ip3root(3)
integer :: i
i = ip3root(1)
end subroutine

! Broadcast real 1d
subroutine rbroadcast1( r )
real, intent(inout) :: r(:)
r = r
end subroutine

! Barrier
subroutine barrier
end subroutine

! Reduce integer
subroutine ireduce( ii, i, op, i2d )
integer, intent(out) :: ii
integer, intent(in) :: i, i2d
character(*), intent(in) :: op
character :: a
a = op(1:1)
ii = i2d
ii = i
end subroutine

! Reduce real
subroutine rreduce( rr, r, op, i2d )
real, intent(out) :: rr
real, intent(in) :: r
integer, intent(in) :: i2d
character(*), intent(in) :: op
character :: a
a = op(1:1)
rr = i2d
rr = r
end subroutine

! Reduce real 1d
subroutine rreduce1( rr, r, op, i2d )
real, intent(out) :: rr(:)
real, intent(in) :: r(:)
integer, intent(in) :: i2d
character(*), intent(in) :: op
character :: a
a = op(1:1)
rr = i2d
rr = r
end subroutine

! Reduce real 2d
subroutine rreduce2( rr, r, op, i2d )
real, intent(out) :: rr(:,:)
real, intent(in) :: r(:,:)
integer, intent(in) :: i2d
character(*), intent(in) :: op
character :: a
a = op(1:1)
rr = i2d
rr = r
end subroutine

! Reduce extrema location, real 3d
subroutine reduceloc( rr, ii, r, op, n, noff, i2d )
real, intent(out) :: rr
real, intent(in) :: r(:,:,:)
integer, intent(out) :: ii(3)
integer, intent(in) :: n(3), noff(3), i2d
character(*), intent(in) :: op
character :: a
a = op(1:1)
ii = n + noff + i2d
select case( op )
case( 'min', 'allmin' ); ii = minloc( r );
case( 'max', 'allmax' ); ii = maxloc( r );
case default; stop 'unknown op in reduceloc'
end select
rr = r(ii(1),ii(2),ii(3))
end subroutine

! Scalar swap halo
subroutine scalar_swap_halo( f, n )
real, intent(inout) :: f(:,:,:)
integer, intent(in) :: n(3)
return
f(1,1,1) = f(1,1,1) - n(1) + n(1)
end subroutine

! Vector swap halo
subroutine vector_swap_halo( f, n )
real, intent(inout) :: f(:,:,:,:)
integer, intent(in) :: n(3)
return
f(1,1,1,1) = f(1,1,1,1) - n(1) + n(1)
end subroutine

! 1D input/output
subroutine rio1( fh, f, mode, filename, m, o, mpio, verb )
use m_frio
integer, intent(inout) :: fh
real, intent(inout) :: f(:)
character(1), intent(in) :: mode
character(*), intent(in) :: filename
integer, intent(in) :: m, o, mpio
logical, intent(in) :: verb
real :: ff(1,size(f))
integer :: i
if ( mode == 'w' ) ff(1,:) = f
call frio2( fh, ff, mode, filename, m, o, verb )
if ( mode == 'r' ) f = ff(1,:) 
i = mpio
end subroutine

! 2D input/output
subroutine rio2( fh, f, mode, filename, mm, nn, oo, mpio, verb )
use m_frio
integer, intent(inout) :: fh
real, intent(inout) :: f(:,:)
character(1), intent(in) :: mode
character(*), intent(in) :: filename
integer, intent(in) :: mm(:), nn(:), oo(:), mpio
logical, intent(in) :: verb
integer :: i
if ( any( nn < 1 ) ) return
i = size( oo )
call frio2( fh, f, mode, filename, mm(i), oo(i), verb )
i = mpio + nn(1)
end subroutine

end module

! Allocate arrays
module m_arrays
implicit none
contains

subroutine arrays
use m_globals
integer :: i1(3), i2(3), j, k, l, j1, k1, l1, j2, k2, l2

! 3d
j = nm(1)
k = nm(2)
l = nm(3)

! 3d vectors
allocate(         &
    vv(j,k,l,3),  &
    uu(j,k,l,3),  &
!   z1(j,k,l,3),  &
!   z2(j,k,l,3),  &
    w1(j,k,l,3),  &
    w2(j,k,l,3)   )

! 3d scalars
allocate(         &
    vc(j,k,l),    &
    mr(j,k,l),    &
    lam(j,k,l),   &
    mu(j,k,l),    &
    gam(j,k,l),   &
!   qp(j,k,l),    &
!   qs(j,k,l),    &
    yy(j,k,l),    &
    s1(j,k,l),    &
    s2(j,k,l)     )

! PML
i1 = 0
i2 = 0
where ( bc1 > 2 ) i1 = npml
where ( bc2 > 2 ) i2 = npml
j1 = i1(1); j2 = i2(1)
k1 = i1(2); k2 = i2(2)
l1 = i1(3); l2 = i2(3)

! PML state
allocate(         &
    p1(j1,k,l,3), &
    g1(j1,k,l,3), &
    p2(j,k1,l,3), &
    g2(j,k1,l,3), &
    p3(j,k,l1,3), &
    g3(j,k,l1,3), &
    p4(j2,k,l,3), &
    g4(j2,k,l,3), &
    p5(j,k2,l,3), &
    g5(j,k2,l,3), &
    p6(j,k,l2,3), &
    g6(j,k,l2,3)  )

! PML damping
allocate( dn1(npml), dn2(npml), dc1(npml), dc2(npml) )

! Fault
if ( ifn /= 0 ) then
    i1 = nm
    i1(ifn) = 1
else
    i1 = 0
end if
j = i1(1)
k = i1(2)
l = i1(3)

! Fault vectors
allocate(          &
    nhat(j,k,l,3), &
    t0(j,k,l,3),   &
    t1(j,k,l,3),   &
    t2(j,k,l,3),   &
    t3(j,k,l,3)    )

! Fault scalars
allocate(         &
    mus(j,k,l),   &
    mud(j,k,l),   &
    dc(j,k,l),    &
    co(j,k,l),    &
    area(j,k,l),  &
    rhypo(j,k,l), &
    lamf(j,k,l),  &
    muf(j,k,l),   &
    sl(j,k,l),    &
    psv(j,k,l),   &
    trup(j,k,l),  &
    tarr(j,k,l),  &
    tn(j,k,l),    &
    ts(j,k,l),    &
    f1(j,k,l),    &
    f2(j,k,l)     )

end subroutine

end module

! Field input and output
module m_fieldio
implicit none
type t_io
    character(32) :: filename      ! filename on disk of the input or output
    character(4) :: field          ! field variable name, see fieldnames.py for list of possible names
    character(8) :: tfunc          ! time function, see time_function in util.f90 for possibilies
    character(3) :: mode           ! 'r' read, 'w' write
    integer :: ii(3,4), nb, ib, fh ! nb: i/o buffer size in time steps, ib: currenc place in buffer, fh: file handle
    real :: x1(3), x2(3), val, period
    real, pointer :: buff(:,:)     ! buffer for storing mutilple time steps
    type( t_io ), pointer :: next  ! pointer to next member of the field i/o list 
end type t_io
type( t_io ), pointer :: pio0, p, pprev
integer, private :: itdebug = -1, idebug
contains

! Append linked list item
subroutine pappend
allocate( p%next )
p => p%next
p%next => pio0
end subroutine

! Remove linked list item
subroutine pdelete
pprev%next => p%next
deallocate( p )
p => pprev
end subroutine

! Field I/O locations
subroutine fieldio_locs
use m_globals
use m_util
use m_collective
real :: rr
integer :: i1(3), i2(3), n(3), noff(3), i

if ( verb ) write( 0, * ) 'Field I/O locations'

! Store locations
if ( master ) then
    open( 1, file='locations.py', status='replace' )
    write( 1, '(a)' ) 'locations = ['
end if

! Loop over output zones
p => pio0
loop: do while( p%next%field /= 'head' )
pprev => p
p => p%next

! Locate nearest node/cell to given location
i = scan( p%mode, 'xX' )
if ( i > 0 ) then
    s2 = huge( rr )
    select case( p%mode(i:i) )
    case( 'x' )
        i1 = i1core
        i2 = i2core
        call radius( s2, w1, p%x1, i1, i2 )
    case( 'X' )
        i1 = max( i1core, i1cell )
        i2 = min( i2core, i2cell )
        call radius( s2, w2, p%x1, i1, i2 )
    end select
    p%mode(i:i) = ' '
    n = nn + 2 * nhalo
    noff = nnoff + nhalo
    call reduceloc( rr, i1, s2, 'allmin', n, noff, 0 )
    p%ii(1,1:3) = i1 + nnoff
    p%ii(2,1:3) = i1 + nnoff
    if ( rr < sum( dx * dx ) / 3.0 ) then
        if ( master ) then
            write(1, '( "( [ ", 4("(", i8, 2(", ", i8), "), "), "], ''", a, "'' )," )')&
                p%ii, trim( p%filename )
        end if
    else
        if ( master ) then
            write(1, '( "#( [ ", 4("(", i8, 2(", ", i8), "), "), "], ''", a, "'' )," )')&
                p%ii, trim( p%filename )
        end if
        call pdelete
    end if
end if

end do loop

if ( master ) then
    write( 1, '(a)' ) ']'
    close( 1 )
end if

end subroutine

!------------------------------------------------------------------------------!

! Field I/O sequence
subroutine fieldio( passes, field, f )
use m_globals
use m_util
use m_collective
use m_frio
character(*), intent(in) :: passes, field
real, intent(inout) :: f(:,:,:)
character(4) :: pass
integer :: i1(3), i2(3), i3(3), i4(3), di(3), m(4), n(4), o(4), &
    it1, it2, dit, i, j, k, l, ipass
real :: val

! Start timer
val = timer( 2 )
!if ( verb ) write( 0, * ) 'Field I/O ', passes, field

! Pass loop
do ipass = 1, len( passes )
pass = passes(ipass:ipass)
p => pio0

! I/O list loop
loop: do while( p%next%field /= 'head' )
pprev => p
p => p%next

! 4D slice
i1 = p%ii(1,1:3) - nnoff
i2 = p%ii(2,1:3) - nnoff
di = p%ii(3,1:3)
it1 = p%ii(1,4)
it2 = p%ii(2,4)
dit = p%ii(3,4)

! Time indices
if ( it > it2 ) then
    call pdelete
    cycle loop
end if
if ( it < it1 ) cycle loop
if ( modulo( it - it1, dit ) /= 0 ) cycle loop

! Spatial indices
i3 = i1
i4 = i2
where( i1 < i1core ) i1 = i1 + ( (i1core - i1 - 1) / di + 1 ) * di
where( i2 > i2core ) i2 = i1 + (  i2core - i1    ) / di       * di
m(1:3) = (i4 - i3) / di + 1
n(1:3) = (i2 - i1) / di + 1
o(1:3) = (i1 - i3) / di

! Dimensionality
i3 = i1
i4 = i2
do i = 1, 3
    if ( size( f, i ) == 1 ) then
        if ( n(i) < 1 ) then
            call pdelete
            cycle loop
        end if
        i1(i) = 1
        i2(i) = 1
        m(i) = 1
        n(i) = 1
        o(i) = 0
    end if
end do

! Pass test
if ( field /= p%field ) cycle loop
if ( pass == '<' .and. p%mode(2:2) == 'w' ) cycle loop
if ( pass == '>' .and. p%mode(2:2) /= 'w' ) cycle loop

! I/O
val = p%val * time_function( p%tfunc, tm, dt, p%period )
select case( p%mode )
case( '=c', '+c' )
    call setcube( f, w1, i3, i4, di, p%x1, p%x2, val, p%mode )
case( '=C', '+C' )
    call setcube( f, w2, i3, i4, di, p%x1, p%x2, val, p%mode )
case( '=' )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
        f(j,k,l) = val
    end do
    end do
    end do
case( '+' )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
        f(j,k,l) = f(j,k,l) + val
    end do
    end do
    end do
case( '=i' )
    if ( all( i1 == i2 ) ) then
        do l = i1(3) - 1, i1(3)
        do k = i1(2) - 1, i1(2)
        do j = i1(1) - 1, i1(1)
            f(j,k,l) = val * &
                ( ( 1.0 - abs( p%x1(1) - j - nnoff(1) ) ) &
                * ( 1.0 - abs( p%x1(2) - k - nnoff(2) ) ) &
                * ( 1.0 - abs( p%x1(3) - l - nnoff(3) ) ) )
        end do
        end do
        end do
    end if
case( '+i' )
    if ( all( i1 == i2 ) ) then
        do l = i1(3) - 1, i1(3)
        do k = i1(2) - 1, i1(2)
        do j = i1(1) - 1, i1(1)
            f(j,k,l) = f(j,k,l) + val * &
                ( ( 1.0 - abs( p%x1(1) - j - nnoff(1) ) ) &
                * ( 1.0 - abs( p%x1(2) - k - nnoff(2) ) ) &
                * ( 1.0 - abs( p%x1(3) - l - nnoff(3) ) ) )
        end do
        end do
        end do
    end if
case( '=s' )
    call random_number( s1 )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
        f(j,k,l) = val * s1(j,k,l)
    end do
    end do
    end do
case( '+s' )
    call random_number( s1 )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
        f(j,k,l) = f(j,k,l) + val * s1(j,k,l)
    end do
    end do
    end do
case( '=r', '+r', '=R', '+R' )
    if ( p%mode(2:2) == 'R' ) then
        do i = 1, 3
            if ( m(i) == 1 ) then
                i1(i) = 1
                i2(i) = 1
                n(i) = 1
                o(i) = 0
            end if
        end do
    end if
    if ( p%ib < 0 ) then
        allocate( p%buff(n(1)*n(2)*n(3),p%nb) )
        p%ib = p%nb
        p%fh = frio_file_null
        if ( mpin /= 0 ) p%fh = file_null
    end if
    if ( p%ib == p%nb ) then
        n(4) = min( p%nb, (it2 - it) / dit + 1 )
        m(4) = (it2 - it1) / dit + 1
        o(4) = (it  - it1) / dit
        str = 'in/' // p%filename
        if ( any( n(1:3) /= m(1:3) ) .and. mpin == 0 ) &
            write( str, '(2a,i6.6)' ) trim( str ), '-', ipid
        call rio2( p%fh, p%buff(:,:n(4)), 'r', str, m, n, o, mpin, verb )
        p%ib = 0
        if ( any( n < 1 ) ) then
            deallocate( p%buff )
            call pdelete
            cycle loop
        end if
    end if
    p%ib = p%ib + 1
    i = 0
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
        i = i + 1
        s1(j,k,l) = p%buff(i,p%ib)
    end do
    end do
    end do
    if ( any( di > 1 ) ) then
        i1 = p%ii(1,1:3) - nnoff
        i2 = p%ii(2,1:3) - nnoff
        if ( any( di > nhalo .and. np3 > 1 ) ) stop 'di too large for nhalo'
        call scalar_swap_halo( s1, nhalo )
        call interpolate( s1, i1, i2, di )
    end if
    if ( p%mode(2:2) == 'R' ) then
        if ( m(1) == 1 ) then
            i2(1) = size( s1, 1 )
            do i = 2, i2(1); s1(i,:,:) = s1(1,:,:); end do
        end if
        if ( m(2) == 1 ) then
            i2(2) = size( s1, 2 )
            do i = 2, i2(2); s1(:,i,:) = s1(:,1,:); end do
        end if
        if ( m(3) == 1 ) then
            i2(3) = size( s1, 3 )
            do i = 2, i2(3); s1(:,:,i) = s1(:,:,1); end do
        end if
    end if
    if ( p%mode(1:1) == '=' ) then
        do l = i1(3), i2(3)
        do k = i1(2), i2(2)
        do j = i1(1), i2(1)
            f(j,k,l) = s1(j,k,l)
        end do
        end do
        end do
    elseif ( p%mode(1:1) == '+' ) then
        do l = i1(3), i2(3)
        do k = i1(2), i2(2)
        do j = i1(1), i2(1)
            f(j,k,l) = f(j,k,l) + s1(j,k,l)
        end do
        end do
        end do
    end if
    if ( it == it2 ) then
        deallocate( p%buff )
        call pdelete
        cycle loop
    end if
case( '=w', '=wi' )
    if ( p%ib < 0 ) then
        allocate( p%buff(n(1)*n(2)*n(3),p%nb) )
        p%ib = 0
        p%fh = frio_file_null
        if ( mpout /= 0 ) p%fh = file_null
    end if
    if ( modulo( it, itstats ) /= 0 ) then
        select case( p%field )
        case( 'vm2' ); call vector_norm( f, vv, i1, i2, di )
        case( 'um2' ); call vector_norm( f, uu, i1, i2, di )
        case( 'wm2' ); call tensor_norm( f, w1, w2, i1, i2, di )
        case( 'am2' ); call vector_norm( f, w1, i1, i2, di )
        end select
    end if
    p%ib = p%ib + 1
    if ( p%mode == '=wi' .and. all( i1 == i2 ) ) then
        p%buff(1,p%ib) = 0.0
        do l = i1(3) - 1, i2(3)
        do k = i1(2) - 1, i2(2)
        do j = i1(1) - 1, i2(1)
            p%buff(1,p%ib) = p%buff(1,p%ib) + f(j,k,l) * &
                ( ( 1.0 - abs( p%x1(1) - j - nnoff(1) ) ) &
                * ( 1.0 - abs( p%x1(2) - k - nnoff(2) ) ) &
                * ( 1.0 - abs( p%x1(3) - l - nnoff(3) ) ) )
        end do
        end do
        end do
    else
        i = 0
        do l = i1(3), i2(3), di(3)
        do k = i1(2), i2(2), di(2)
        do j = i1(1), i2(1), di(1)
            i = i + 1
            p%buff(i,p%ib) = f(j,k,l)
        end do
        end do
        end do
    end if
    if ( p%ib == p%nb .or. it == it2 .or. modulo( it, itio ) == 0 ) then
        n(4) = p%ib
        m(4) = (it2 - it1) / dit + 1
        o(4) = (it  - it1) / dit + 1 - n(4)
        str = 'out/' // p%filename
        if ( any( n(1:3) /= m(1:3) ) .and. mpout == 0 ) &
            write( str, '(2a,i6.6)' ) trim( str ), '-', ipid
        call rio2( p%fh, p%buff(:,:n(4)), 'w', str, m, n, o, mpout, verb )
        p%ib = 0
        if ( it == it2 .or. any( n < 1 ) ) then
            deallocate( p%buff )
            call pdelete
            cycle loop
        end if
    end if
case default
    write( 0, * ) "bad i/o mode '", trim( p%mode ), "' for ", trim( p%filename )
    stop
end select

end do loop
end do

! Debug output
i = scan( passes, '>' )
if ( i > 0 .and. debug > 3 .and. it <= 8 ) then
    if ( itdebug /= it ) then
        itdebug = it
        idebug = 0
    end if
    idebug = idebug + 1
    write( str, "(a,3(i4.4,'-'),a)" ) 'debug/f', it, ipid, idebug, field
    write( 0, * ) 'Opening file: ', trim( str )
    open( 1, file=str, status='replace' )
    do l = 1, size( f, 3 )
        write( 1, * ) it, l, field
        do k = 1, size( f, 2 )
            write( 1, * ) f(:,k,l)
        end do
    end do
    close( 1 )
end if

! Timer
if (sync) call barrier
iotimer = iotimer + timer( 2 )

end subroutine

!------------------------------------------------------------------------------!

subroutine setcube( f, x, i1, i2, di, x1, x2, r, mode )
real, intent(inout) :: f(:,:,:)
real, intent(in) :: x(:,:,:,:), x1(3), x2(3), r
integer, intent(in) :: i1(3), i2(3), di(3)
character(*), intent(in) :: mode
integer :: n(3), o(3), j, k, l
n = (/ size(f,1), size(f,2), size(f,3) /)
o = 0
where ( n == 1 ) o = 1 - i1
select case( mode(1:1) )
case( '=' )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
    if( x(j,k,l,1) >= x1(1) .and. x(j,k,l,1) <= x2(1) .and. &
        x(j,k,l,2) >= x1(2) .and. x(j,k,l,2) <= x2(2) .and. &
        x(j,k,l,3) >= x1(3) .and. x(j,k,l,3) <= x2(3) ) &
        f(j+o(1),k+o(2),l+o(3)) = r
    end do
    end do
    end do
case( '+' )
    do l = i1(3), i2(3), di(3)
    do k = i1(2), i2(2), di(2)
    do j = i1(1), i2(1), di(1)
    if( x(j,k,l,1) >= x1(1) .and. x(j,k,l,1) <= x2(1) .and. &
        x(j,k,l,2) >= x1(2) .and. x(j,k,l,2) <= x2(2) .and. &
        x(j,k,l,3) >= x1(3) .and. x(j,k,l,3) <= x2(3) ) &
        f(j+o(1),k+o(2),l+o(3)) = f(j+o(1),k+o(2),l+o(3)) + r
    end do
    end do
    end do
case default; stop 'error in cube'
end select
end subroutine

end module

! Collect statistics
module m_stats
real :: &
    amax, vmax, umax, wmax, &
    samax, svmax, sumax, slmax, &
    tsmax, tnmin, tnmax, tarrmax, &
    efric, estrain, moment
contains

! Write statistics
subroutine stats
use m_globals
use m_collective
use m_util
logical, save :: init = .true., dofault = .false.
integer, save :: fh(16), j = 0
integer :: m, o, i
real :: rr
real, save, allocatable, dimension(:,:) :: &
    vstats, fstats, estats, gvstats, gfstats, gestats

! Start timer
if ( verb ) write( 0, * ) 'Statistics'

! Allocate buffers
if ( init ) then
    init = .false.
    if ( faultnormal /= 0 ) then
        i = abs( faultnormal )
        if ( ip3(i) == ip3root(i) ) dofault = .true.
    end if
    allocate( vstats(4,itio), fstats(8,itio), estats(3,itio), &
        gvstats(4,itio), gfstats(8,itio), gestats(3,itio) )
    vstats = 0.0
    fstats = 0.0
    estats = 0.0
    gvstats = 0.0
    gfstats = 0.0
    gestats = 0.0
    fh = -1
    if ( mpout /= 0 ) fh = file_null
end if

! Buffer stats
if ( modulo( it, itstats ) == 0 ) then
    j = j + 1
    vstats(1,j) = amax
    vstats(2,j) = vmax
    vstats(3,j) = umax
    vstats(4,j) = wmax
    rr = maxval( vstats )
    if ( rr /= rr .or. rr > huge( rr ) ) stop 'NaN/Inf!'
    if ( dofault ) then
        fstats(1,j) = samax
        fstats(2,j) = svmax
        fstats(3,j) = sumax
        fstats(4,j) = slmax
        fstats(5,j) = tsmax
        fstats(6,j) = -tnmin
        fstats(7,j) = tnmax
        fstats(8,j) = tarrmax
        estats(1,j) = efric
        estats(2,j) = estrain
        estats(3,j) = moment
    end if
end if

! Write stats
if ( j > 0 .and. ( modulo( it, itio ) == 0 .or. it == nt ) ) then
    rr = timer( 2 )
    call rreduce2( gvstats, vstats, 'max', 0 )
    if ( dofault ) then
        call rreduce2( gfstats, fstats, 'max', ifn )
        call rreduce2( gestats, estats, 'sum', ifn )
    end if
    if (sync) call barrier
    mptimer = mptimer + timer( 2 )
    if ( master ) then
        m = nt / itstats
        o = it / itstats - j
        gvstats = sqrt( gvstats )
        call rio1( fh(1), gvstats(1,:j), 'w', 'stats/amax', m, o, mpout, verb )
        call rio1( fh(2), gvstats(2,:j), 'w', 'stats/vmax', m, o, mpout, verb )
        call rio1( fh(3), gvstats(3,:j), 'w', 'stats/umax', m, o, mpout, verb )
        call rio1( fh(4), gvstats(4,:j), 'w', 'stats/wmax', m, o, mpout, verb )
        if ( dofault ) then
            gfstats(6,:j) = -gfstats(6,:j)
            call rio1( fh(5),  gfstats(1,:j), 'w', 'stats/samax',   m, o, mpout, verb )
            call rio1( fh(6),  gfstats(2,:j), 'w', 'stats/svmax',   m, o, mpout, verb )
            call rio1( fh(7),  gfstats(3,:j), 'w', 'stats/sumax',   m, o, mpout, verb )
            call rio1( fh(8),  gfstats(4,:j), 'w', 'stats/slmax',   m, o, mpout, verb )
            call rio1( fh(9),  gfstats(5,:j), 'w', 'stats/tsmax',   m, o, mpout, verb )
            call rio1( fh(10), gfstats(6,:j), 'w', 'stats/tnmin',   m, o, mpout, verb )
            call rio1( fh(11), gfstats(7,:j), 'w', 'stats/tnmax',   m, o, mpout, verb )
            call rio1( fh(12), gfstats(8,:j), 'w', 'stats/tarrmax', m, o, mpout, verb )
            call rio1( fh(13), gestats(1,:j), 'w', 'stats/efric',   m, o, mpout, verb )
            call rio1( fh(14), gestats(2,:j), 'w', 'stats/estrain', m, o, mpout, verb )
            call rio1( fh(15), gestats(3,:j), 'w', 'stats/moment',  m, o, mpout, verb )
            do i = 1, j
                if ( gestats(3,i) > 0.0 ) then
                    gestats(3,i) = ( log10( gestats(3,i) ) - 9.05 ) / 1.5
                else
                    gestats(3,i) = -999
                end if
            end do
            call rio1( fh(16), gestats(3,:j), 'w', 'stats/mw',      m, o, mpout, verb )
        end if
    end if
    j = 0
    if (sync) call barrier
    iotimer = iotimer + timer( 2 )
end if

end subroutine

end module

! Read model parameters
module m_parameters
implicit none
contains

subroutine read_parameters
use m_globals
use m_fieldio
integer :: io, i
character(12) :: key
character(1) :: op
character(256) :: line

! I/O pointers
allocate( pio0 )
p => pio0
p%next => pio0
p%field = 'head'

open( 1, file='parameters.py', status='old' )

doline: do

! Read line
read( 1, '(a)', iostat=io ) line
if ( io /= 0 ) exit doline

! Strip comments and punctuation
str = line
i = scan( str, '#' )
if ( i > 0 ) str(i:) = ' '
do
    i = scan( str, "()[]{}'," )
    if ( i == 0 ) exit
    str(i:i) = ' '
end do

! Read key val pair
if ( str == '' ) cycle doline
read( str, *, iostat=io ) key

! Select input key
select case( key )
case( 'fieldio', '' )
case( 'nn' );           read( str, *, iostat=io ) key, op, nn
case( 'nt' );           read( str, *, iostat=io ) key, op, nt
case( 'dx' );           read( str, *, iostat=io ) key, op, dx
case( 'dt' );           read( str, *, iostat=io ) key, op, dt
case( 'tm0' );          read( str, *, iostat=io ) key, op, tm0
case( 'affine' );       read( str, *, iostat=io ) key, op, affine
case( 'n1expand' );     read( str, *, iostat=io ) key, op, n1expand
case( 'n2expand' );     read( str, *, iostat=io ) key, op, n2expand
case( 'rexpand' );      read( str, *, iostat=io ) key, op, rexpand
case( 'gridnoise' );    read( str, *, iostat=io ) key, op, gridnoise
case( 'oplevel' );      read( str, *, iostat=io ) key, op, oplevel
case( 'rho1' );         read( str, *, iostat=io ) key, op, rho1
case( 'rho2' );         read( str, *, iostat=io ) key, op, rho2
case( 'vp1' );          read( str, *, iostat=io ) key, op, vp1
case( 'vp2' );          read( str, *, iostat=io ) key, op, vp2
case( 'vs1' );          read( str, *, iostat=io ) key, op, vs1
case( 'vs2' );          read( str, *, iostat=io ) key, op, vs2
case( 'gam1' );         read( str, *, iostat=io ) key, op, gam1
case( 'gam2' );         read( str, *, iostat=io ) key, op, gam2
case( 'vdamp' );        read( str, *, iostat=io ) key, op, vdamp
case( 'hourglass' );    read( str, *, iostat=io ) key, op, hourglass
case( 'bc1' );          read( str, *, iostat=io ) key, op, bc1
case( 'bc2' );          read( str, *, iostat=io ) key, op, bc2
case( 'npml' );         read( str, *, iostat=io ) key, op, npml
case( 'i1pml' );        read( str, *, iostat=io ) key, op, i1pml
case( 'i2pml' );        read( str, *, iostat=io ) key, op, i2pml
case( 'ppml' );         read( str, *, iostat=io ) key, op, ppml
case( 'vpml' );         read( str, *, iostat=io ) key, op, vpml
case( 'xhypo' );        read( str, *, iostat=io ) key, op, xhypo
case( 'ihypo' );        read( str, *, iostat=io ) key, op, ihypo
case( 'fixhypo' );      read( str, *, iostat=io ) key, op, fixhypo
case( 'source' );       read( str, *, iostat=io ) key, op, source
case( 'timefunction' ); read( str, *, iostat=io ) key, op, timefunction
case( 'period' );       read( str, *, iostat=io ) key, op, period
case( 'source1' );      read( str, *, iostat=io ) key, op, source1
case( 'source2' );      read( str, *, iostat=io ) key, op, source2
case( 'nsource' );      read( str, *, iostat=io ) key, op, nsource
case( 'faultnormal' );  read( str, *, iostat=io ) key, op, faultnormal
case( 'slipvector' );   read( str, *, iostat=io ) key, op, slipvector
case( 'faultopening' ); read( str, *, iostat=io ) key, op, faultopening
case( 'vrup' );         read( str, *, iostat=io ) key, op, vrup
case( 'rcrit' );        read( str, *, iostat=io ) key, op, rcrit
case( 'trelax' );       read( str, *, iostat=io ) key, op, trelax
case( 'svtol' );        read( str, *, iostat=io ) key, op, svtol
case( 'np3' );          read( str, *, iostat=io ) key, op, np3
case( 'itstats' );      read( str, *, iostat=io ) key, op, itstats
case( 'itio' );         read( str, *, iostat=io ) key, op, itio
case( 'itcheck' );      read( str, *, iostat=io ) key, op, itcheck
case( 'itstop' );       read( str, *, iostat=io ) key, op, itstop
case( 'debug' );        read( str, *, iostat=io ) key, op, debug
case( 'mpin' );         read( str, *, iostat=io ) key, op, mpin
case( 'mpout' );        read( str, *, iostat=io ) key, op, mpout
case default
    select case( key(1:1) )
    case( '=', '+' )
        call pappend
        p%ib = -1
        read( str, *, iostat=io ) p%mode, p%tfunc, p%period, p%x1, p%x2, p%nb, &
            p%ii, p%field, p%filename, p%val
    case default; io = 1
    end select
end select

! Error check
if ( io /= 0 ) then
    if ( master ) write( 0, * ) 'bad input: ', trim( line )
    stop
end if

end do doline

close( 1 )

end subroutine

end module

! Setup model dimensions
module m_setup
implicit none
contains

subroutine setup
use m_globals
use m_collective
use m_util
integer :: nl(3)

nt = max( nt, 0 )
ifn = abs( faultnormal )

! Partition for parallelization
if ( np0 == 1 ) np3 = 1
nl = (nn - 1) / np3 + 1
nhalo = 1
if ( ifn /= 0 ) nhalo(ifn) = 2
nl = max( nl, nhalo )
np3 = (nn - 1) / nl + 1
call rank( ip3, ipid, np3 )
nnoff = nl * ip3 - nhalo

! Master process
ip3root = (ihypo - 1.0) / nl
master = .false.
if ( all( ip3 == ip3root ) ) master = .true.
call setroot( ip3root )

! Size of arrays
nl = min( nl, nn - nnoff - nhalo )
nm = nl + 2 * nhalo

! Boundary conditions
i1bc = 1  - nnoff
i2bc = nn - nnoff

! Non-overlapping core region
i1core = 1  + nhalo
i2core = nm - nhalo

! Node region
i1node = max( i1bc, 2 )
i2node = min( i2bc, nm - 1 )

! Cell region
i1cell = max( i1bc, 1 )
i2cell = min( i2bc - 1, nm - 1 )

! PML region
i1pml = i1pml - nnoff
i2pml = i2pml - nnoff

! Map rupture index to local indices, and test if fault on this process
irup = 0
if ( ifn /= 0 ) then
    irup = int( ihypo(ifn) + 0.000001 ) - nnoff(ifn)
    if ( irup + 1 < i1core(ifn) .or. irup > i2core(ifn) ) ifn = 0
end if

! Debugging
verb = master .and. debug > 0
sync = debug > 1
if ( debug > 2 ) then
    write( str, "( a,i6.6,a )" ) 'debug/db', ipid, '.py'
    open( 1, file=str, status='replace' )
    write( 1, "( 'ifn     = ', i8                                            )" ) ifn
    write( 1, "( 'irup    = ', i8                                            )" ) irup
    write( 1, "( 'ip      = ', i8                                            )" ) ip
    write( 1, "( 'ipid    = ', i8                                            )" ) ipid
    write( 1, "( 'np3     = ', i8, 2(',', i8)                                )" ) np3
    write( 1, "( 'ip3     = ', i8, 2(',', i8)                                )" ) ip3
    write( 1, "( 'nn      = ', i8, 2(',', i8)                                )" ) nn
    write( 1, "( 'nm      = ', i8, 2(',', i8)                                )" ) nm
    write( 1, "( 'bc1     = ', i8, 2(',', i8)                                )" ) bc1
    write( 1, "( 'bc2     = ', i8, 2(',', i8)                                )" ) bc2
    write( 1, "( 'nhalo   = ', i8, 2(',', i8)                                )" ) nhalo
    write( 1, "( 'nnoff   = ', i8, 2(',', i8)                                )" ) nnoff
    write( 1, "( 'i1bc    = ', i8, 2(',', i8), '; i2bc   = ', i8, 2(',', i8) )" ) i1bc, i2bc
    write( 1, "( 'i1pml   = ', i8, 2(',', i8), '; i2pml  = ', i8, 2(',', i8) )" ) i1pml, i2pml
    write( 1, "( 'i1core  = ', i8, 2(',', i8), '; i2core = ', i8, 2(',', i8) )" ) i1core, i2core
    write( 1, "( 'i1node  = ', i8, 2(',', i8), '; i2node = ', i8, 2(',', i8) )" ) i1node, i2node
    write( 1, "( 'i1cell  = ', i8, 2(',', i8), '; i2cell = ', i8, 2(',', i8) )" ) i1cell, i2cell
    close( 1 )
end if

end subroutine

end module

! Grid generation
module m_grid_gen
implicit none
contains

subroutine grid_gen
use m_globals
use m_collective
use m_bc
use m_util
use m_diffnc
use m_fieldio
integer :: i1(3), i2(3), i3(3), i4(3), bc(3), &
    i, j, k, l, j1, k1, l1, j2, k2, l2, b, c
real :: x0(3), xi(3), m(9), tol, h, w
integer, allocatable :: seed(:)

if ( master ) write( 0, * ) 'Grid generation'

! Create rectangular mesh with double nodes at the fault
w1 = 0.
i1 = i1core
i2 = i2core
do i = i1(1), i2(1); w1(i,:,:,1) = dx(1) * (i + nnoff(1) - 1); end do
do i = i1(2), i2(2); w1(:,i,:,2) = dx(2) * (i + nnoff(2) - 1); end do
do i = i1(3), i2(3); w1(:,:,i,3) = dx(3) * (i + nnoff(3) - 1); end do
if ( faultnormal /= 0 ) then
    i1 = max( i1core, irup + 1 )
    select case( abs( faultnormal ) )
    case( 1 ); do i = i1(1), i2(1); w1(i,:,:,1) = dx(1) * (i + nnoff(1) - 2); end do
    case( 2 ); do i = i1(2), i2(2); w1(:,i,:,2) = dx(2) * (i + nnoff(2) - 2); end do
    case( 3 ); do i = i1(3), i2(3); w1(:,:,i,3) = dx(3) * (i + nnoff(3) - 2); end do
    end select
end if

! Read grid
call fieldio( '<', 'x1', w1(:,:,:,1) )
call fieldio( '<', 'x2', w1(:,:,:,2) )
call fieldio( '<', 'x3', w1(:,:,:,3) )

! Add random noise except at boundaries and in PML
if ( gridnoise > 0.0 ) then
    call random_seed( size=i )
    allocate( seed(i) )
    seed = ip
    call random_seed( put=seed )
    call random_number( w2 )
    w2 = sqrt( sum( dx * dx ) ) * gridnoise * ( w2 - 0.5 )
    i1 = i1pml + 1
    i2 = i2pml - 1
    call set_halo( w2(:,:,:,1), 0.0, i1, i2 )
    call set_halo( w2(:,:,:,2), 0.0, i1, i2 )
    call set_halo( w2(:,:,:,3), 0.0, i1, i2 )
    i1 = i1bc + 1
    i2 = i2bc - 1
    call set_halo( w2(:,:,:,1), 0.0, i1, i2 )
    call set_halo( w2(:,:,:,2), 0.0, i1, i2 )
    call set_halo( w2(:,:,:,3), 0.0, i1, i2 )
    i1 = max( i1core, irup )
    i2 = min( i2core, irup + 1 )
    select case( abs( faultnormal ) )
    case( 1 ); w2(i1(1):i2(1),:,:,:) = 0.0
    case( 2 ); w2(:,i1(2):i2(2),:,:) = 0.0
    case( 3 ); w2(:,:,i1(3):i2(3),:) = 0.0
    end select
    w1 = w1 + w2
end if

! Grid expansion
if ( rexpand > 1.0 ) then
    i1 = n1expand - nnoff
    i2 = nn - n2expand + 1 - nnoff
    i3 = i1core
    i4 = i2core
    do j = i3(1), min( i4(1), i1(1) )
        i = i1(1) - j
        w1(j,:,:,1) = w1(j,:,:,1) + &
            dx(1) * ( i + 1 - (rexpand ** (i + 1) - 1) / (rexpand - 1) )
    end do
    do j = max( i3(1), i2(1) ), i4(1)
        i = j - i2(1)
        w1(j,:,:,1) = w1(j,:,:,1) - &
            dx(1) * ( i + 1 - (rexpand ** (i + 1) - 1) / (rexpand - 1) )
    end do
    do k = i3(2), min( i4(2), i1(2) )
        i = i1(2) - k
        w1(:,k,:,2) = w1(:,k,:,2) + &
            dx(2) * ( i + 1 - (rexpand ** (i + 1) - 1) / (rexpand - 1) )
    end do
    do k = max( i3(2), i2(2) ), i4(2)
        i = k - i2(2)
        w1(:,k,:,2) = w1(:,k,:,2) - &
            dx(2) * ( i + 1 - (rexpand ** (i + 1) - 1) / (rexpand - 1) )
    end do
    do l = i3(3), min( i4(3), i1(3) )
        i = i1(3) - l
        w1(:,:,l,3) = w1(:,:,l,3) + &
            dx(3) * ( i + 1 - (rexpand ** (i + 1) - 1) / (rexpand - 1) )
    end do
    do l = max( i3(3), i2(3) ), i4(3)
        i = l - i2(3)
        w1(:,:,l,3) = w1(:,:,l,3) - &
            dx(3) * ( i + 1 - (rexpand ** (i + 1) - 1) / (rexpand - 1) )
    end do
end if

! Affine grid transformation
m = affine
do l = 1, nm(3)
do k = 1, nm(2)
do j = 1, nm(1)
    w2(j,k,l,1) = m(1) * w1(j,k,l,1) + m(2) * w1(j,k,l,2) + m(3) * w1(j,k,l,3)
    w2(j,k,l,2) = m(4) * w1(j,k,l,1) + m(5) * w1(j,k,l,2) + m(6) * w1(j,k,l,3)
    w2(j,k,l,3) = m(7) * w1(j,k,l,1) + m(8) * w1(j,k,l,2) + m(9) * w1(j,k,l,3)
end do
end do
end do
w1 = w2

! Fill halo, bc=4 means copy into halo, need this for nhat
bc = 4
i1 = i1bc - 1
i2 = i2bc + 1
call vector_swap_halo( w1, nhalo )
call vector_bc( w1, bc, bc, i1, i2 )

! Cell centers
call average( w2(:,:,:,1), w1(:,:,:,1), i1cell, i2cell, 1 )
call average( w2(:,:,:,2), w1(:,:,:,2), i1cell, i2cell, 1 )
call average( w2(:,:,:,3), w1(:,:,:,3), i1cell, i2cell, 1 )

! Hypocenter location
if ( fixhypo /= 0 ) then
    if ( master ) then
        xi = ihypo - nnoff
        i1 = int( xi )
        x0 = 0.0
        do l = i1(3), i1(3)+1
        do k = i1(2), i1(2)+1
        do j = i1(1), i1(1)+1
            w = (1.0-abs(xi(1)-j)) * (1.0-abs(xi(2)-k)) * (1.0-abs(xi(3)-l))
            do i = 1, 3
                x0(i) = x0(i) + w * w1(j,k,l,i)
            end do
        end do
        end do
        end do
    end if
    call rbroadcast1( x0 )
end if
if ( fixhypo > 0 ) then
    xhypo = x0
elseif ( fixhypo < 0 ) then
    do i = 1, 3
    do l = 1, nm(3)
    do k = 1, nm(2)
    do j = 1, nm(1)
        w1(j,k,l,i) = w1(j,k,l,i) - x0(i) + xhypo(i)
        w2(j,k,l,i) = w2(j,k,l,i) - x0(i) + xhypo(i)
    end do
    end do
    end do
    end do
end if

! Zero external cells
call set_halo( w2(:,:,:,1), 0.0, i1cell, i2cell )
call set_halo( w2(:,:,:,2), 0.0, i1cell, i2cell )
call set_halo( w2(:,:,:,3), 0.0, i1cell, i2cell )

! Find indices for coordinate based i/o
call fieldio_locs

! Output
call fieldio( '>', 'x1', w1(:,:,:,1) )
call fieldio( '>', 'x2', w1(:,:,:,2) )
call fieldio( '>', 'x3', w1(:,:,:,3) )
call fieldio( '>', 'c1', w2(:,:,:,1) )
call fieldio( '>', 'c2', w2(:,:,:,2) )
call fieldio( '>', 'c3', w2(:,:,:,3) )

! Orthogonality test
if ( oplevel == 0 ) then
    oplevel = 6
    tol = 10.0 * epsilon( tol )
    j1 = i1cell(1); j2 = i2cell(1)
    k1 = i1cell(2); k2 = i2cell(2)
    l1 = i1cell(3); l2 = i2cell(3)
    if ( &
    sum( abs( w1(j1+1:j2+1,:,:,2) - w1(j1:j2,:,:,2) ) ) < tol .and. &
    sum( abs( w1(j1+1:j2+1,:,:,3) - w1(j1:j2,:,:,3) ) ) < tol .and. &
    sum( abs( w1(:,k1+1:k2+1,:,3) - w1(:,k1:k2,:,3) ) ) < tol .and. &
    sum( abs( w1(:,k1+1:k2+1,:,1) - w1(:,k1:k2,:,1) ) ) < tol .and. &
    sum( abs( w1(:,:,l1+1:l2+1,1) - w1(:,:,l1:l2,1) ) ) < tol .and. &
    sum( abs( w1(:,:,l1+1:l2+1,2) - w1(:,:,l1:l2,2) ) ) < tol ) oplevel = 2
end if

! Operators
select case( oplevel )
case( 1 )
case( 2 )
    allocate( dx1(nm(1)), dx2(nm(2)), dx3(nm(3)) )
    do i = 1, nm(1)-1; dx1(i) = w1(i+1,3,3,1) - w1(i,3,3,1); end do
    do i = 1, nm(2)-1; dx2(i) = w1(3,i+1,3,2) - w1(3,i,3,2); end do
    do i = 1, nm(3)-1; dx3(i) = w1(3,3,i+1,3) - w1(3,3,i,3); end do
case( 3:5 )
    allocate( xx(nm(1),nm(2),nm(3),3) )
    xx = w1
case( 6 )
    allocate( bb(nm(1),nm(2),nm(3),8,3) )
    do i = 1, 3
    h = sign( 1.0 / 12.0, product( dx ) )
    b = modulo( i, 3 ) + 1
    c = modulo( i + 1, 3 ) + 1
    do l = 1, nm(3)-1
    do k = 1, nm(2)-1
    do j = 1, nm(1)-1
    bb(j,k,l,1,i) = h * &
        ((w1(j+1,k,l,b)-w1(j,k+1,l+1,b))*(w1(j+1,k+1,l,c)-w1(j+1,k,l+1,c))+w1(j,k+1,l+1,b)*(w1(j,k,l+1,c)-w1(j,k+1,l,c)) &
        +(w1(j,k+1,l,b)-w1(j+1,k,l+1,b))*(w1(j,k+1,l+1,c)-w1(j+1,k+1,l,c))+w1(j+1,k,l+1,b)*(w1(j+1,k,l,c)-w1(j,k,l+1,c)) &
        +(w1(j,k,l+1,b)-w1(j+1,k+1,l,b))*(w1(j+1,k,l+1,c)-w1(j,k+1,l+1,c))+w1(j+1,k+1,l,b)*(w1(j,k+1,l,c)-w1(j+1,k,l,c)))
    bb(j,k,l,2,i) = h * &
        ((w1(j+1,k+1,l+1,b)-w1(j,k,l,b))*(w1(j+1,k,l+1,c)-w1(j+1,k+1,l,c))+w1(j,k,l,b)*(w1(j,k+1,l,c)-w1(j,k,l+1,c)) &
        +(w1(j,k+1,l,b)-w1(j+1,k,l+1,b))*(w1(j+1,k+1,l,c)-w1(j,k,l,c))+w1(j+1,k,l+1,b)*(w1(j,k,l+1,c)-w1(j+1,k+1,l+1,c)) &
        +(w1(j,k,l+1,b)-w1(j+1,k+1,l,b))*(w1(j,k,l,c)-w1(j+1,k,l+1,c))+w1(j+1,k+1,l,b)*(w1(j+1,k+1,l+1,c)-w1(j,k+1,l,c)))
    bb(j,k,l,3,i) = h * &
        ((w1(j+1,k+1,l+1,b)-w1(j,k,l,b))*(w1(j+1,k+1,l,c)-w1(j,k+1,l+1,c))+w1(j,k,l,b)*(w1(j,k,l+1,c)-w1(j+1,k,l,c)) &
        +(w1(j+1,k,l,b)-w1(j,k+1,l+1,b))*(w1(j,k,l,c)-w1(j+1,k+1,l,c))+w1(j,k+1,l+1,b)*(w1(j+1,k+1,l+1,c)-w1(j,k,l+1,c)) &
        +(w1(j,k,l+1,b)-w1(j+1,k+1,l,b))*(w1(j,k+1,l+1,c)-w1(j,k,l,c))+w1(j+1,k+1,l,b)*(w1(j+1,k,l,c)-w1(j+1,k+1,l+1,c)))
    bb(j,k,l,4,i) = h * &
        ((w1(j+1,k+1,l+1,b)-w1(j,k,l,b))*(w1(j,k+1,l+1,c)-w1(j+1,k,l+1,c))+w1(j,k,l,b)*(w1(j+1,k,l,c)-w1(j,k+1,l,c)) &
        +(w1(j+1,k,l,b)-w1(j,k+1,l+1,b))*(w1(j+1,k,l+1,c)-w1(j,k,l,c))+w1(j,k+1,l+1,b)*(w1(j,k+1,l,c)-w1(j+1,k+1,l+1,c)) &
        +(w1(j,k+1,l,b)-w1(j+1,k,l+1,b))*(w1(j,k,l,c)-w1(j,k+1,l+1,c))+w1(j+1,k,l+1,b)*(w1(j+1,k+1,l+1,c)-w1(j+1,k,l,c)))
    bb(j,k,l,5,i) = h * &
        ((w1(j,k+1,l+1,b)-w1(j+1,k,l,b))*(w1(j,k+1,l,c)-w1(j,k,l+1,c))+w1(j+1,k,l,b)*(w1(j+1,k,l+1,c)-w1(j+1,k+1,l,c)) &
        +(w1(j+1,k,l+1,b)-w1(j,k+1,l,b))*(w1(j,k,l+1,c)-w1(j+1,k,l,c))+w1(j,k+1,l,b)*(w1(j+1,k+1,l,c)-w1(j,k+1,l+1,c)) &
        +(w1(j+1,k+1,l,b)-w1(j,k,l+1,b))*(w1(j+1,k,l,c)-w1(j,k+1,l,c))+w1(j,k,l+1,b)*(w1(j,k+1,l+1,c)-w1(j+1,k,l+1,c)))
    bb(j,k,l,6,i) = h * &
        ((w1(j,k,l,b)-w1(j+1,k+1,l+1,b))*(w1(j,k,l+1,c)-w1(j,k+1,l,c))+w1(j+1,k+1,l+1,b)*(w1(j+1,k+1,l,c)-w1(j+1,k,l+1,c)) &
        +(w1(j+1,k,l+1,b)-w1(j,k+1,l,b))*(w1(j+1,k+1,l+1,c)-w1(j,k,l+1,c))+w1(j,k+1,l,b)*(w1(j,k,l,c)-w1(j+1,k+1,l,c)) &
        +(w1(j+1,k+1,l,b)-w1(j,k,l+1,b))*(w1(j,k+1,l,c)-w1(j+1,k+1,l+1,c))+w1(j,k,l+1,b)*(w1(j+1,k,l+1,c)-w1(j,k,l,c)))
    bb(j,k,l,7,i) = h * &
        ((w1(j,k,l,b)-w1(j+1,k+1,l+1,b))*(w1(j+1,k,l,c)-w1(j,k,l+1,c))+w1(j+1,k+1,l+1,b)*(w1(j,k+1,l+1,c)-w1(j+1,k+1,l,c)) &
        +(w1(j,k+1,l+1,b)-w1(j+1,k,l,b))*(w1(j,k,l+1,c)-w1(j+1,k+1,l+1,c))+w1(j+1,k,l,b)*(w1(j+1,k+1,l,c)-w1(j,k,l,c)) &
        +(w1(j+1,k+1,l,b)-w1(j,k,l+1,b))*(w1(j+1,k+1,l+1,c)-w1(j+1,k,l,c))+w1(j,k,l+1,b)*(w1(j,k,l,c)-w1(j,k+1,l+1,c)))
    bb(j,k,l,8,i) = h * &
        ((w1(j,k,l,b)-w1(j+1,k+1,l+1,b))*(w1(j,k+1,l,c)-w1(j+1,k,l,c))+w1(j+1,k+1,l+1,b)*(w1(j+1,k,l+1,c)-w1(j,k+1,l+1,c)) &
        +(w1(j,k+1,l+1,b)-w1(j+1,k,l,b))*(w1(j+1,k+1,l+1,c)-w1(j,k+1,l,c))+w1(j+1,k,l,b)*(w1(j,k,l,c)-w1(j+1,k,l+1,c)) &
        +(w1(j+1,k,l+1,b)-w1(j,k+1,l,b))*(w1(j+1,k,l,c)-w1(j+1,k+1,l+1,c))+w1(j,k+1,l,b)*(w1(j,k+1,l+1,c)-w1(j,k,l,c)))
    end do
    end do
    end do
    end do
case default; stop 'illegal operator'
end select

! Cell volume
call set_halo( vc, 0.0, i1cell, i2cell )
do i = 1, 3
    call diffnc( vc, w1, i, i, i1cell, i2cell, oplevel, bb, xx, dx1, dx2, dx3, dx )
    select case( ifn ) 
    case( 1 ); vc(irup,:,:) = 0.0
    case( 2 ); vc(:,irup,:) = 0.0
    case( 3 ); vc(:,:,irup) = 0.0
    end select
    if ( minval( vc ) < 0.0 ) stop 'negative cell volume, wrong sign in dx?'
end do
call fieldio( '>', 'vc', vc  )

end subroutine

end module

! Material model
module m_material
implicit none
contains

subroutine material
use m_globals
use m_collective
use m_util
use m_fieldio
real :: vstats(8), gvstats(8), r, rho_, vp_, vs_, gam_, courant
integer :: i1(3), i2(3)

if ( master ) write( 0, * ) 'Material model'

! Init
mr = 0.0
lam = 0.0
mu = 0.0
gam = 0.0

! Inputs
call fieldio( '<', 'rho', mr  )
call fieldio( '<', 'vp',  lam  )
call fieldio( '<', 'vs',  mu  )
call fieldio( '<', 'gam', gam )
s1 = lam
s2 = mu

! Test for endian problems
if ( any( mr  /= mr  ) .or. maxval( mr  ) > huge( r ) ) stop 'NaN/Inf in rho'
if ( any( s1  /= s1  ) .or. maxval( s1  ) > huge( r ) ) stop 'NaN/Inf in vp'
if ( any( s2  /= s2  ) .or. maxval( s2  ) > huge( r ) ) stop 'NaN/Inf in vs'
if ( any( gam /= gam ) .or. maxval( gam ) > huge( r ) ) stop 'NaN/Inf in gam'

! Limits
if ( rho1 > 0.0 ) mr = max( mr, rho1 )
if ( rho2 > 0.0 ) mr = min( mr, rho2 )
if ( vp1  > 0.0 ) s1 = max( s1, vp1 )
if ( vp2  > 0.0 ) s1 = min( s1, vp2 )
if ( vs1  > 0.0 ) s2 = max( s2, vs1 )
if ( vs2  > 0.0 ) s2 = min( s2, vs2 )

! Velocity dependent viscosity
if ( vdamp > 0.0 ) then
    gam = s2
    call invert( gam )
    gam = gam * vdamp
end if

! Limits
if ( gam1 > 0.0 ) gam = max( gam, gam1 )
if ( gam2 > 0.0 ) gam = min( gam, gam2 )

! Averages
vstats = 0.0
i1 = max( i1core, i1bc )
i2 = min( i2core, i2bc - 1 )
call set_halo( mr,  0.0, i1, i2 )
call set_halo( s1,  0.0, i1, i2 )
call set_halo( s2,  0.0, i1, i2 )
call set_halo( gam, 0.0, i1, i2 )
vstats(1) = sum( mr  )
vstats(2) = sum( s1  )
vstats(3) = sum( s2  )
vstats(4) = sum( gam )
call rreduce1( gvstats, vstats, 'sum', 0 )
rho_ = gvstats(1) / product( nn - 1 ) 
vp_  = gvstats(2) / product( nn - 1 ) 
vs_  = gvstats(3) / product( nn - 1 ) 
gam_ = gvstats(4) / product( nn - 1 ) 

! Fill halo
call scalar_swap_halo( mr,  nhalo )
call scalar_swap_halo( s1,  nhalo )
call scalar_swap_halo( s2,  nhalo )
call scalar_swap_halo( gam, nhalo )

! Extrema
call set_halo( mr,  huge(r), i1cell, i2cell )
call set_halo( s1,  huge(r), i1cell, i2cell )
call set_halo( s2,  huge(r), i1cell, i2cell )
call set_halo( gam, huge(r), i1cell, i2cell )
vstats(1) = -minval( mr  )
vstats(2) = -minval( s1  )
vstats(3) = -minval( s2  )
vstats(4) = -minval( gam )
call set_halo( mr,  0.0, i1cell, i2cell )
call set_halo( s1,  0.0, i1cell, i2cell )
call set_halo( s2,  0.0, i1cell, i2cell )
call set_halo( gam, 0.0, i1cell, i2cell )
vstats(5) = maxval( mr  )
vstats(6) = maxval( s1  )
vstats(7) = maxval( s2  )
vstats(8) = maxval( gam )
call rreduce1( gvstats, vstats, 'allmax', 0 )
rho1 = -gvstats(1)
vp1  = -gvstats(2)
vs1  = -gvstats(3)
gam1 = -gvstats(4)
rho2 =  gvstats(5)
vp2  =  gvstats(6)
vs2  =  gvstats(7)
gam2 =  gvstats(8)

! Stats
if ( master ) then
    courant = dt * vp2 * 3.0 / sqrt( sum( dx * dx ) )
    open( 1, file='stats/material.py', status='replace' )
    write( 1, "( 'courant = ',g15.7 )" ) courant
    write( 1, "( 'rho_    = ',g15.7 )" ) rho_
    write( 1, "( 'rho1    = ',g15.7 )" ) rho1
    write( 1, "( 'rho2    = ',g15.7 )" ) rho2
    write( 1, "( 'vp_     = ',g15.7 )" ) vp_
    write( 1, "( 'vp1     = ',g15.7 )" ) vp1
    write( 1, "( 'vp2     = ',g15.7 )" ) vp2
    write( 1, "( 'vs_     = ',g15.7 )" ) vs_
    write( 1, "( 'vs1     = ',g15.7 )" ) vs1
    write( 1, "( 'vs2     = ',g15.7 )" ) vs2
    write( 1, "( 'gam_    = ',g15.7 )" ) gam_
    write( 1, "( 'gam1    = ',g15.7 )" ) gam1
    write( 1, "( 'gam2    = ',g15.7 )" ) gam2
    close( 1 )
end if

! Lame' parameters
mu  = mr * s2 * s2
lam = mr * s1 * s1 - 2.0 * mu

! Hourglass constant
yy = 12.0 * (lam + 2.0 * mu)
call invert( yy )
yy = yy * sqrt( sum( dx * dx ) / 3.0 ) * mu * (lam + mu)
!yy = 0.3 / 16.0 * ( lam + 2.0 * mu ) * sqrt( sum( dx * dx ) / 3.0 ) ! like Ma & Liu, 2006

! Output
call fieldio( '>', 'rho', mr  )
call fieldio( '>', 'vp',  s1  )
call fieldio( '>', 'vs',  s2  )
call fieldio( '>', 'gam', gam )
call fieldio( '>', 'mu',  mu  )
call fieldio( '>', 'lam', lam )
call fieldio( '>', 'yy',  yy  )

end subroutine

!------------------------------------------------------------------------------!

! Calculate PML damping parameters
subroutine pml
use m_globals
integer :: i
real :: c1, c2, c3, damp, dampn, dampc, tune

if ( npml < 1 ) return
c1 =  8.0 / 15.0
c2 = -3.0 / 100.0
c3 =  1.0 / 1500.0
tune = 3.5
if ( vpml <= 0.0 ) vpml = 2.0 * vs1 * vs2 / (vs1 + vs2)
damp = tune * vpml / sqrt( sum( dx * dx ) / 3.0 ) * (c1 + (c2 + c3 * npml) * npml) / npml ** ppml
do i = 1, npml
    dampn = damp *  i ** ppml
    dampc = damp * (i ** ppml + (i - 1) ** ppml) * 0.5
    dn1(npml-i+1) = -2.0 * dampn       / (2.0 + dt * dampn)
    dc1(npml-i+1) = (2.0 - dt * dampc) / (2.0 + dt * dampc)
    dn2(npml-i+1) =  2.0               / (2.0 + dt * dampn)
    dc2(npml-i+1) =  2.0 * dt          / (2.0 + dt * dampc)
end do

end subroutine

end module

! Kinematic source
module m_source
implicit none
integer, private, allocatable :: src_nt(:)
real, private, allocatable :: src_xi(:,:), src_dt(:), src_t0(:), &
    src_w1(:,:), src_w2(:,:), src_history(:)
contains

! Initialize finite source
subroutine finite_source_init
use m_globals
use m_collective
use m_util
integer :: n, i, fh
if ( nsource == 0 ) return
if ( master ) write( 0, * ) 'Finite source initialize'
n = abs( nsource )
allocate( src_xi(n,3) )
fh = -1
if ( mpin /= 0 ) fh = file_null
call rio1( fh, src_xi(:,1), 'r', 'in/src_xi1',     n, 0, mpin, verb )
call rio1( fh, src_xi(:,2), 'r', 'in/src_xi2',     n, 0, mpin, verb )
call rio1( fh, src_xi(:,3), 'r', 'in/src_xi3',     n, 0, mpin, verb )
if ( source == 'force' ) then
    do i = 1, 3
        src_xi(:,i) = src_xi(:,i) - nnoff(i)
        if ( all( src_xi(:,i) < (-1.0 + i1node(i)) ) .or. &
             all( src_xi(:,i) > ( 1.0 + i2node(i)) ) ) then
            nsource = 0
            deallocate( src_xi )
            return
        end if
    end do
    allocate( src_nt(n), src_dt(n), src_t0(n), src_w1(n,3) )
    call rio1( fh, src_w1(:,1), 'r', 'in/src_w11', n, 0, mpin, verb )
    call rio1( fh, src_w1(:,2), 'r', 'in/src_w12', n, 0, mpin, verb )
    call rio1( fh, src_w1(:,3), 'r', 'in/src_w13', n, 0, mpin, verb )
else
    do i = 1, 3
        src_xi(:,i) = src_xi(:,i) - 0.5 - nnoff(i)
        if ( all( src_xi(:,i) < (-1.0 + i1cell(i)) ) .or. &
             all( src_xi(:,i) > ( 1.0 + i2cell(i)) ) ) then
            nsource = 0
            deallocate( src_xi )
            return
        end if
    end do
    allocate( src_nt(n), src_dt(n), src_t0(n), src_w1(n,3), src_w2(n,3) )
    call rio1( fh, src_w1(:,1), 'r', 'in/src_w11', n, 0, mpin, verb )
    call rio1( fh, src_w1(:,2), 'r', 'in/src_w22', n, 0, mpin, verb )
    call rio1( fh, src_w1(:,3), 'r', 'in/src_w33', n, 0, mpin, verb )
    call rio1( fh, src_w2(:,1), 'r', 'in/src_w23', n, 0, mpin, verb )
    call rio1( fh, src_w2(:,2), 'r', 'in/src_w31', n, 0, mpin, verb )
    call rio1( fh, src_w2(:,3), 'r', 'in/src_w12', n, 0, mpin, verb )
end if
call rio1( fh, src_t0,       'r', 'in/src_t0',     n, 0, mpin, verb )
call rio1( fh, src_dt,       'r', 'in/src_nt',     n, 0, mpin, verb )
src_nt = int( src_dt + 0.5 )
call rio1( fh, src_dt,       'r', 'in/src_dt',     n, 0, mpin, verb )
n = sum( src_nt )
allocate( src_history(n) )
call rio1( fh, src_history,  'r', 'in/src_history', n, 0, mpin, verb )
end subroutine

! Add finite source to force vector or strain/stress tensor
subroutine finite_source
use m_globals
integer :: i1(3), i2(3), i, j, k, l, isrc, itoff
real :: xi(3), t, h, w
if ( nsource == 0 ) return
if ( verb ) write( 0, * ) 'Finite source'
itoff = 0
do isrc = 1, abs( nsource )
    i = floor( ( tm - src_t0(isrc) ) / src_dt(isrc) ) + 1
    xi = src_xi(isrc,:)
    if ( source == 'force' ) then
        i1 = max( i1node, int( xi )     )
        i2 = min( i2node, int( xi ) + 1 )
    else
        i1 = max( i1cell, int( xi )     )
        i2 = min( i2cell, int( xi ) + 1 )
    end if
    if ( i >= 0 .and. all( i2 >= i1 ) ) then
        i = min( i, src_nt(isrc) - 1 )
        t = src_t0(isrc) + src_dt(isrc) * (i - 1)
        h = min( 1.0, (tm - t) / src_dt(isrc) )
        if ( i == 0 ) then
            h = h * src_history(itoff+1)
        else
            h = ( 1.0 - h ) * src_history(itoff+i) + h * src_history(itoff+i+1)
        end if
        if ( source == 'force' ) then
            do l = i1(3), i2(3)
            do k = i1(2), i2(2)
            do j = i1(1), i2(1)
                w = h * ((1.0-abs(xi(1)-j)) * (1.0-abs(xi(2)-k)) * (1.0-abs(xi(3)-l)))
                do i = 1, 3
                    w1(j,k,l,i) = w1(j,k,l,i) + w * src_w1(isrc,i)
                end do
            end do
            end do
            end do
        else
            do l = i1(3), i2(3)
            do k = i1(2), i2(2)
            do j = i1(1), i2(1)
                w = h * vc(j,k,l) * ((1.0-abs(xi(1)-j)) * (1.0-abs(xi(2)-k)) * (1.0-abs(xi(3)-l)))
                do i = 1, 3
                    w1(j,k,l,i) = w1(j,k,l,i) - w * src_w1(isrc,i)
                    w2(j,k,l,i) = w2(j,k,l,i) - w * src_w2(isrc,i)
                end do
            end do
            end do
            end do
        end if
    end if
    itoff = itoff + src_nt(isrc)
end do
end subroutine

! Add point source to vector
subroutine vector_point_source
use m_globals
use m_util
integer :: i1(3), i2(3), i, j, k, l
real :: xi(3), f, w
if ( timefunction == 'none' ) return
xi = ihypo - nnoff
i1 = max( i1node, int( xi )     )
i2 = min( i2node, int( xi ) + 1 )
if ( any( i2 < i1 ) ) then
    timefunction = 'none'
    return
end if
if ( verb ) write( 0, * ) 'Point source'
f = time_function( timefunction, tm, dt, period )
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
    w = f * ( (1.0-abs(xi(1)-j)) * (1.0-abs(xi(2)-k)) * (1.0-abs(xi(3)-l)) )
    do i = 1, 3
        w1(j,k,l,i) = w1(j,k,l,i) + w * source1(i)
    end do
end do
end do
end do
end subroutine

! Add point source to strain/stress tensor
subroutine tensor_point_source
use m_globals
use m_util
integer :: i1(3), i2(3), i, j, k, l
real :: xi(3), f, w
if ( timefunction == 'none' ) return
xi = ihypo - 0.5 - nnoff
i1 = max( i1cell, int( xi )     )
i2 = min( i2cell, int( xi ) + 1 )
if ( any( i2 < i1 ) ) then
    timefunction = 'none'
    return
end if
if ( verb ) write( 0, * ) 'Point source'
f = time_function( timefunction, tm, dt, period )
do l = i1(3), i2(3)
do k = i1(2), i2(2)
do j = i1(1), i2(1)
    w = f * vc(j,k,l) * ( (1.0-abs(xi(1)-j)) * (1.0-abs(xi(2)-k)) * (1.0-abs(xi(3)-l)) )
    do i = 1, 3
        w1(j,k,l,i) = w1(j,k,l,i) - w * source1(i)
        w2(j,k,l,i) = w2(j,k,l,i) - w * source2(i)
    end do
end do
end do
end do
end subroutine

end module

! Rupture boundary condition
module m_rupture
implicit none
contains

! Rupture initialization
subroutine rupture_init
use m_globals
use m_collective
use m_surfnormals
use m_util
use m_fieldio
use m_stats
real :: rr
integer :: i1(3), i2(3), i, j, k, l

if ( ifn == 0 ) return
if ( master ) write( 0, * ) 'Rupture initialization'

! I/O
mus = 0.0
mud = 0.0
dc = 0.0
co = 0.0
t1 = 0.0
t2 = 0.0
t3 = 0.0
call fieldio( '<>', 'mus', mus         )
call fieldio( '<>', 'mud', mud         )
call fieldio( '<>', 'dc',  dc          )
call fieldio( '<>', 'co',  co          )
call fieldio( '<>', 's11', t1(:,:,:,1) )
call fieldio( '<>', 's22', t1(:,:,:,2) )
call fieldio( '<>', 's33', t1(:,:,:,3) )
call fieldio( '<>', 's23', t2(:,:,:,1) )
call fieldio( '<>', 's31', t2(:,:,:,2) )
call fieldio( '<>', 's12', t2(:,:,:,3) )
call fieldio( '<>', 'ts',  t3(:,:,:,1) )
call fieldio( '<>', 'td',  t3(:,:,:,2) )
call fieldio( '<>', 'tn',  t3(:,:,:,3) )

! Test for endian problems
if ( any( mus /= mus ) .or. maxval( mus ) > huge( rr ) ) stop 'NaN/Inf in mus'
if ( any( mud /= mud ) .or. maxval( mud ) > huge( rr ) ) stop 'NaN/Inf in mud'
if ( any( dc  /= dc  ) .or. maxval( dc  ) > huge( rr ) ) stop 'NaN/Inf in dc'
if ( any( co  /= co  ) .or. maxval( co  ) > huge( rr ) ) stop 'NaN/Inf in co'
if ( any( t1  /= t1  ) .or. maxval( t1  ) > huge( rr ) ) stop 'NaN/Inf in sigma'
if ( any( t2  /= t2  ) .or. maxval( t2  ) > huge( rr ) ) stop 'NaN/Inf in sigma'
if ( any( t3  /= t3  ) .or. maxval( t3  ) > huge( rr ) ) stop 'NaN/Inf in tau'

! Normal traction check
i1 = maxloc( t3(:,:,:,3) )
rr = t3(i1(1),i1(2),i1(3),3)
i1(ifn) = irup
i1 = i1 + nnoff
if ( rr > 0.0 ) write( 0, * ) 'warning: positive normal traction: ', rr, i1

! Lock fault in PML region
i1 = i1pml + 1
i2 = i2pml - 1
call set_halo( co, 1e20, i1, i2 )

! Normal vectors
i1 = i1core
i2 = i2core
i1(ifn) = irup
i2(ifn) = irup
call surfnormals( nhat, w1, dx, i1, i2, ifn )
area = sign( 1, faultnormal ) * sqrt( sum( nhat * nhat, 4 ) )
f1 = area
call invert( f1 )
do i = 1, 3
    nhat(:,:,:,i) = nhat(:,:,:,i) * f1
end do
call fieldio( '>', 'nhat1', nhat(:,:,:,1) )
call fieldio( '>', 'nhat2', nhat(:,:,:,2) )
call fieldio( '>', 'nhat3', nhat(:,:,:,3) )

! Resolve prestress onto fault
do i = 1, 3
    j = modulo( i , 3 ) + 1
    k = modulo( i + 1, 3 ) + 1
    t0(:,:,:,i) = &
    t1(:,:,:,i) * nhat(:,:,:,i) + &
    t2(:,:,:,j) * nhat(:,:,:,k) + &
    t2(:,:,:,k) * nhat(:,:,:,j)
end do

! Ts2 vector
t2(:,:,:,1) = nhat(:,:,:,2) * slipvector(3) - nhat(:,:,:,3) * slipvector(2)
t2(:,:,:,2) = nhat(:,:,:,3) * slipvector(1) - nhat(:,:,:,1) * slipvector(3)
t2(:,:,:,3) = nhat(:,:,:,1) * slipvector(2) - nhat(:,:,:,2) * slipvector(1)
f1 = sqrt( sum( t2 * t2, 4 ) )
call invert( f1 )
do i = 1, 3
    t2(:,:,:,i) = t2(:,:,:,i) * f1
end do

! Ts1 vector
t1(:,:,:,1) = t2(:,:,:,2) * nhat(:,:,:,3) - t2(:,:,:,3) * nhat(:,:,:,2)
t1(:,:,:,2) = t2(:,:,:,3) * nhat(:,:,:,1) - t2(:,:,:,1) * nhat(:,:,:,3)
t1(:,:,:,3) = t2(:,:,:,1) * nhat(:,:,:,2) - t2(:,:,:,2) * nhat(:,:,:,1)
f1 = sqrt( sum( t1 * t1, 4 ) )
call invert( f1 )
do i = 1, 3
    t1(:,:,:,i) = t1(:,:,:,i) * f1
end do

! Total pretraction
do i = 1, 3
    t0(:,:,:,i) = t0(:,:,:,i) + &
    t3(:,:,:,1) * t1(:,:,:,i) + &
    t3(:,:,:,2) * t2(:,:,:,i) + &
    t3(:,:,:,3) * nhat(:,:,:,i)
end do

! Hypocentral radius
do i = 1, 3
    select case( ifn )
    case ( 1 ); t2(1,:,:,i) = w1(irup,:,:,i) - xhypo(i)
    case ( 2 ); t2(:,1,:,i) = w1(:,irup,:,i) - xhypo(i)
    case ( 3 ); t2(:,:,1,i) = w1(:,:,irup,i) - xhypo(i)
    end select
end do
rhypo = sqrt( sum( t2 * t2, 4 ) )

! Resample mu on to fault plane nodes for moment calculatioin
select case( ifn )
case ( 1 ); lamf(1,:,:) = lam(irup,:,:); muf(1,:,:) = mu(irup,:,:)
case ( 2 ); lamf(:,1,:) = lam(:,irup,:); muf(:,1,:) = mu(:,irup,:)
case ( 3 ); lamf(:,:,1) = lam(:,:,irup); muf(:,:,1) = mu(:,:,irup)
end select
call invert( lamf )
call invert( muf )
j = nm(1) - 1
k = nm(2) - 1
l = nm(3) - 1
if ( ifn /= 1 ) lamf(2:j,:,:) = .5 * ( lamf(2:j,:,:) + lamf(1:j-1,:,:) )
if ( ifn /= 2 ) lamf(:,2:k,:) = .5 * ( lamf(:,2:k,:) + lamf(:,1:k-1,:) )
if ( ifn /= 3 ) lamf(:,:,2:l) = .5 * ( lamf(:,:,2:l) + lamf(:,:,1:l-1) )
if ( ifn /= 1 ) muf(2:j,:,:) = .5 * ( muf(2:j,:,:) + muf(1:j-1,:,:) )
if ( ifn /= 2 ) muf(:,2:k,:) = .5 * ( muf(:,2:k,:) + muf(:,1:k-1,:) )
if ( ifn /= 3 ) muf(:,:,2:l) = .5 * ( muf(:,:,2:l) + muf(:,:,1:l-1) )
call invert( muf )

! Initial state, can be overwritten by read_checkpoint
psv   =  0.0
trup  =  1e9
tarr  =  0.0
efric =  0.0

! Halos
call scalar_swap_halo( mus,   nhalo )
call scalar_swap_halo( mud,   nhalo )
call scalar_swap_halo( dc,    nhalo )
call scalar_swap_halo( co,    nhalo )
call scalar_swap_halo( area,  nhalo )
call scalar_swap_halo( rhypo, nhalo )
call vector_swap_halo( nhat,  nhalo )
call vector_swap_halo( t0,    nhalo )

end subroutine

!------------------------------------------------------------------------------!

! Rupture boundary condition
subroutine rupture
use m_globals
use m_collective
use m_bc
use m_util
use m_fieldio
use m_stats
integer :: i1(3), i2(3), i, j1, k1, l1, j2, k2, l2, j3, k3, l3, j4, k4, l4

if ( ifn == 0 ) return
if ( verb ) write( 0, * ) 'Rupture'

! Indices
i1 = 1
i2 = nm
i1(ifn) = irup
i2(ifn) = irup
j1 = i1(1); j2 = i2(1)
k1 = i1(2); k2 = i2(2)
l1 = i1(3); l2 = i2(3)
i1(ifn) = irup + 1
i2(ifn) = irup + 1
j3 = i1(1); j4 = i2(1)
k3 = i1(2); k4 = i2(2)
l3 = i1(3); l4 = i2(3)

! Trial traction for zero velocity and zero displacement
f1 = dt * dt * area * ( mr(j1:j2,k1:k2,l1:l2) + mr(j3:j4,k3:k4,l3:l4) )
call invert( f1 )
do i = 1, 3
    t1(:,:,:,i) = t0(:,:,:,i) + f1 * dt * &
        ( vv(j3:j4,k3:k4,l3:l4,i) &
        - vv(j1:j2,k1:k2,l1:l2,i) &
        + w1(j3:j4,k3:k4,l3:l4,i) * mr(j3:j4,k3:k4,l3:l4) * dt &
        - w1(j1:j2,k1:k2,l1:l2,i) * mr(j1:j2,k1:k2,l1:l2) * dt )
    t2(:,:,:,i) = t1(:,:,:,i) + f1 * &
        ( uu(j3:j4,k3:k4,l3:l4,i) - uu(j1:j2,k1:k2,l1:l2,i) )
end do

! Shear and normal traction
tn = sum( t1 * nhat, 4 )
do i = 1, 3
    t3(:,:,:,i) = t1(:,:,:,i) - tn * nhat(:,:,:,i)
end do
ts = sqrt( sum( t3 * t3, 4 ) )

! Delay slip till after first iteration
if ( it > 1 ) then

    ! Normal traction
    tn = sum( t2 * nhat, 4 )
    if ( faultopening == 1 ) tn = min( 0.0, tn )

    ! Slip velocity
    do i = 1, 3
        t2(:,:,:,i) = vv(j3:j4,k3:k4,l3:l4,i) - vv(j1:j2,k1:k2,l1:l2,i)
    end do
    f2 = sum( t2 * t2, 4 )

    ! Slip-weakening friction law
    f1 = mud
    where ( sl < dc ) f1 = f1 + (1.0 - sl / dc) * (mus - mud)
    f1 = -min( 0.0, tn ) * f1 + co

    ! Nucleation
    if ( rcrit > 0.0 .and. vrup > 0.0 ) then
        f2 = 1.0
        if ( trelax > 0.0 ) f2 = min( (tm - rhypo / vrup) / trelax, 1.0 )
        f2 = (1.0 - f2) * ts + f2 * (-tn * mud + co)
        where ( rhypo < min( rcrit, tm * vrup ) .and. f2 < f1 ) f1 = f2
    end if

    ! Shear traction bounded by friction
    f2 = 1.0
    where ( ts > f1 ) f2 = f1 / ts
    do i = 1, 3
        t3(:,:,:,i) = f2 * t3(:,:,:,i)
    end do
    ts = min( ts, f1 )

    ! Total traction
    do i = 1, 3
        t1(:,:,:,i) = t3(:,:,:,i) + tn * nhat(:,:,:,i)
    end do

end if

! Update acceleration
do i = 1, 3
    f2 = area * ( t1(:,:,:,i) - t0(:,:,:,i) )
    w1(j1:j2,k1:k2,l1:l2,i) = w1(j1:j2,k1:k2,l1:l2,i) + f2
    w1(j3:j4,k3:k4,l3:l4,i) = w1(j3:j4,k3:k4,l3:l4,i) - f2
end do
call vector_bc( w1, bc1, bc2, i1bc, i2bc )

! Output
call fieldio( '>', 't1',  t1(:,:,:,1) )
call fieldio( '>', 't2',  t1(:,:,:,2) )
call fieldio( '>', 't3',  t1(:,:,:,3) )
call fieldio( '>', 'ts1', t3(:,:,:,1) )
call fieldio( '>', 'ts2', t3(:,:,:,2) )
call fieldio( '>', 'ts3', t3(:,:,:,2) )
call fieldio( '>', 'tsm', ts          )
call fieldio( '>', 'tnm', tn          )
call fieldio( '>', 'fr',  f1          )
call set_halo( ts,      -1.0, i1core, i2core ); tsmax = maxval( ts ) 
call set_halo( tn,  huge(dt), i1core, i2core ); tnmin = minval( tn )
call set_halo( tn, -huge(dt), i1core, i2core ); tnmax = maxval( tn )
call set_halo( tn,       0.0, i1core, i2core )

! Friction + fracture energy
t2 = vv(j3:j4,k3:k4,l3:l4,:) - vv(j1:j2,k1:k2,l1:l2,:)
f2 = sum( t1 * t2, 4 ) * area
call set_halo( f2, 0.0, i1core, i2core )
efric = efric + dt * sum( f2 )

! Strain energy
t2 = uu(j3:j4,k3:k4,l3:l4,:) - uu(j1:j2,k1:k2,l1:l2,:)
f2 = sum( (t0 + t1) * t2, 4 ) * area
call set_halo( f2, 0.0, i1core, i2core )
estrain = .5 * sum( f2 )

! Moment (negelcts opening lambda contribution)
f2 = muf * area * sqrt( sum( t2 * t2, 4 ) )
call set_halo( f2, 0.0, i1core, i2core )
moment = sum( f2 )

! Slip acceleration
do i = 1, 3
    t2(:,:,:,i) = &
        w1(j3:j4,k3:k4,l3:l4,i) * mr(j3:j4,k3:k4,l3:l4) - &
        w1(j1:j2,k1:k2,l1:l2,i) * mr(j1:j2,k1:k2,l1:l2)
end do
f2 = sqrt( sum( t2 * t2, 4 ) )
call fieldio( '>', 'sa1', t2(:,:,:,1) )
call fieldio( '>', 'sa2', t2(:,:,:,2) )
call fieldio( '>', 'sa3', t2(:,:,:,3) )
call fieldio( '>', 'sam', f2          )
call set_halo( f2, -1.0, i1core, i2core )
samax = maxval( f2 )

end subroutine

end module

! Resample material arrays
module m_resample
implicit none
contains

subroutine resample
use m_globals
use m_collective
use m_bc
use m_util
integer :: i1(3), i2(3), bc(3)

if ( master ) write( 0, * ) 'Resample material model'

! Mass ratio
s2 = mr * vc
call average( mr, s2, i1node, i2node, -1 )
call invert( mr )
call scalar_swap_halo( mr, nhalo )
call scalar_bc( mr, bc1, bc2, i1bc, i2bc )

! Invert cell volume
call invert( vc )

! Viscosity, bc=4 means copy into halo for resampling at the node
bc = 4
i1 = i1bc - 1
i2 = i2bc
call scalar_bc( gam, bc, bc, i1, i2 )
s2 = gam * dt
call average( gam, s2, i1node, i2node, -1 )
call set_halo( gam, 0.0, i1bc, i2bc )
call scalar_swap_halo( gam, nhalo )
call scalar_bc( gam, bc1, bc2, i1bc, i2bc )

! Zero hourglass viscosity outside boundary, and at fault cell
i1 = i1bc
i2 = i2bc - 1
call set_halo( yy, 0.0, i1, i2 )
select case( ifn )
case( 1 ); yy(irup,:,:) = 0.0
case( 2 ); yy(:,irup,:) = 0.0
case( 3 ); yy(:,:,irup) = 0.0
end select

! Initial state
tm = 0.0
vv = 0.0
uu = 0.0
w1 = 0.0
!z1 = 0.0
!z2 = 0.0
sl = 0.0
p1 = 0.0
p2 = 0.0
p3 = 0.0
p4 = 0.0
p5 = 0.0
p6 = 0.0
g1 = 0.0
g2 = 0.0
g3 = 0.0
g4 = 0.0
g5 = 0.0
g6 = 0.0

w2 = 0.0
s1 = 0.0
s2 = 0.0

end subroutine

end module

! Checkpoint restart
module m_checkpoint
implicit none
integer, private :: itcheck0
contains

! Look for checkpoint
subroutine look_for_checkpoint
use m_globals
use m_collective
use m_util
integer :: i
real :: r
r = timer( 2 )
write( str, '(a,i6.6)' ) 'checkpoint/it', ipid
open( 1, file=str, status='old', iostat=i )
if ( i == 0 ) then
    read( 1, * ) it, itcheck0
    close( 1 )
else
    it = 0
end if
call ireduce( i, it, 'allmin', 0 )
it = i
iotimer = iotimer + timer( 2 )
end subroutine

! Read checkpoint
subroutine read_checkpoint
use m_globals
use m_stats
use m_util
integer :: i
real :: r
r = timer( 2 )
if ( it == 0 ) return
if ( master ) write( 0, * ) 'Checkpoint found, starting from ', it
i = modulo( it / itcheck0, 2 )
write( str, '(a,i6.6,a,i6.6)' ) 'checkpoint/cp', i, '-', ipid
inquire( iolength=i ) &
    tm, vv, uu, w1, sl, p1, p2, p3, p4, p5, p6, g1, g2, g3, g4, g5, g6, &
    psv, trup, tarr, efric
open( 1, file=str, recl=i, form='unformatted', access='direct', status='old' )
read( 1, rec=1 ) &
    tm, vv, uu, w1, sl, p1, p2, p3, p4, p5, p6, g1, g2, g3, g4, g5, g6, &
    psv, trup, tarr, efric
close( 1 )
iotimer = iotimer + timer( 2 )
end subroutine

! Write checkpoint
subroutine write_checkpoint
use m_globals
use m_stats
use m_util
use m_collective
integer :: i
real :: r
r = timer( 2 )
if ( verb ) write( 0, * ) 'Checkpoint'
if ( itcheck >= 0 .and. ( it == nt .or. modulo( it, itio ) == 0 ) ) then
    open( 1, file='itcheck', status='old', iostat=i )
    if ( i == 0 ) then
        read( 1, * ) itcheck
        close( 1 )
    end if
end if
iotimer = iotimer + timer( 2 )
if ( itcheck <= 0 ) return
if ( modulo( it, itcheck ) /= 0 ) return
i = modulo( it / itcheck, 2 )
write( str, '(a,i6.6,a,i6.6)' ) 'checkpoint/cp', i, '-', ipid
inquire( iolength=i ) &
    tm, vv, uu, w1, sl, p1, p2, p3, p4, p5, p6, g1, g2, g3, g4, g5, g6, &
    psv, trup, tarr, efric
open( 1, file=str, recl=i, form='unformatted',access='direct',status='replace' )
write( 1, rec=1 ) &
    tm, vv, uu, w1, sl, p1, p2, p3, p4, p5, p6, g1, g2, g3, g4, g5, g6, &
    psv, trup, tarr, efric
close( 1 )
write( str, '(a,i6.6)' ) 'checkpoint/it', ipid
open( 1, file=str, status='replace' )
write( 1, * ) it, itcheck
close( 1 )
if (sync) call barrier
iotimer = iotimer + timer( 2 )
end subroutine

end module

! Time integration
module m_timestep
implicit none
contains

subroutine timestep
use m_globals
use m_util
use m_fieldio
use m_stats

! Status
if ( master ) then
    if ( verb ) then
        write( 0, * ) 'Time step', it
    else
        write( 0, '(a)', advance='no' ) '.'
        if ( modulo( it, 50 ) == 0 .or. it == nt ) write( 0, '(i6)' ) it
    end if
end if

! Save previous slip velocity
if ( ifn /= 0 ) then
    select case( ifn )
    case( 1 ); t2(1,:,:,:) = vv(irup+1,:,:,:) - vv(irup,:,:,:)
    case( 2 ); t2(:,1,:,:) = vv(:,irup+1,:,:) - vv(:,irup,:,:)
    case( 3 ); t2(:,:,1,:) = vv(:,:,irup+1,:) - vv(:,:,irup,:)
    end select
    f2 = sqrt( sum( t2 * t2, 4 ) )
end if

! Velocity time integration
tm = tm0 + dt * ( it - 1 ) - dt * 0.5
vv = vv + dt * w1
call fieldio( '<>', 'v1', vv(:,:,:,1) )
call fieldio( '<>', 'v2', vv(:,:,:,2) )
call fieldio( '<>', 'v3', vv(:,:,:,3) )
if ( modulo( it, itstats ) == 0 ) then
    call vector_norm( s1, vv, i1core, i2core, (/ 1, 1, 1 /) )
    call set_halo( s1, -1.0, i1core, i2core )
    vmax = maxval( s1 )
end if
call fieldio( '>', 'vm2', s1  )

! Displacement time integration
tm = tm0 + dt * ( it - 1 )
uu = uu + dt * vv
call fieldio( '<>', 'u1', uu(:,:,:,1) )
call fieldio( '<>', 'u2', uu(:,:,:,2) )
call fieldio( '<>', 'u3', uu(:,:,:,3) )
if ( modulo( it, itstats ) == 0 ) then
    call vector_norm( s1, uu, i1core, i2core, (/ 1, 1, 1 /) )
    call set_halo( s1, -1.0, i1core, i2core )
    umax = maxval( s1 )
end if
call fieldio( '>', 'um2', s1  )

! Fault time integration
if ( ifn /= 0 ) then
    select case( ifn )
    case( 1 ); t1(1,:,:,:) = vv(irup+1,:,:,:) - vv(irup,:,:,:)
    case( 2 ); t1(:,1,:,:) = vv(:,irup+1,:,:) - vv(:,irup,:,:)
    case( 3 ); t1(:,:,1,:) = vv(:,:,irup+1,:) - vv(:,:,irup,:)
    end select
    f1 = sqrt( sum( t1 * t1, 4 ) )
    sl = sl + dt * f1
    psv = max( psv, f1 )
    if ( svtol > 0.0 ) then
        where ( f1 >= svtol .and. trup > 1e8 )
            trup = tm - dt * ( 0.5 + (svtol - f1) / (f2 - f1) )
        end where
        where ( f1 >= svtol )
            tarr = 1e9
        end where
        where ( f1 < svtol .and. f2 >= svtol )
            tarr = tm - dt * ( 0.5 + (svtol - f1) / (f2 - f1) )
        end where
    end if
    select case( ifn )
    case( 1 ); t2(1,:,:,:) = uu(irup+1,:,:,:) - uu(irup,:,:,:)
    case( 2 ); t2(:,1,:,:) = uu(:,irup+1,:,:) - uu(:,irup,:,:)
    case( 3 ); t2(:,:,1,:) = uu(:,:,irup+1,:) - uu(:,:,irup,:)
    end select
    f2 = sqrt( sum( t2 * t2, 4 ) )
    call fieldio( '>', 'sv1',  t1(:,:,:,1) )
    call fieldio( '>', 'sv2',  t1(:,:,:,2) )
    call fieldio( '>', 'sv3',  t1(:,:,:,3) )
    call fieldio( '>', 'svm',  f1          )
    call fieldio( '>', 'psv',  psv         )
    call fieldio( '>', 'su1',  t2(:,:,:,1) )
    call fieldio( '>', 'su2',  t2(:,:,:,2) )
    call fieldio( '>', 'su3',  t2(:,:,:,3) )
    call fieldio( '>', 'sum',  f2          )
    call fieldio( '>', 'sl',   sl          )
    call fieldio( '>', 'trup', trup        )
    call fieldio( '>', 'tarr', tarr        )
    call set_halo( f1,   -1.0, i1core, i2core )
    call set_halo( f2,   -1.0, i1core, i2core )
    call set_halo( tarr, -1.0, i1core, i2core )
    svmax = maxval( f1 )
    sumax = maxval( f2 )
    slmax = maxval( sl )
    tarrmax = maxval( tarr )
end if

end subroutine
end module

! Stress calculation
module m_stress
implicit none
contains

subroutine stress
use m_globals
use m_diffnc
use m_source
use m_util
use m_fieldio
use m_stats
integer :: i1(3), i2(3), i, j, k, l, ic, iid, id

if ( verb ) write( 0, * ) 'Stress'

! Modified displacement
do i = 1, 3
    w1(:,:,:,i) = uu(:,:,:,i) + gam * vv(:,:,:,i)
end do
call set_halo( s1, 0.0, i1cell, i2cell )

! Loop over component and derivative direction
doic: do ic  = 1, 3
doid: do iid = 1, 3; id = modulo( ic + iid - 1, 3 ) + 1

! Elastic region: g_ij = (u_i + gamma*v_i),j
i1 = max( i1pml + 1, i1cell )
i2 = min( i2pml - 2, i2cell )
call diffnc( s1, w1, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )

! PML region, non-damped directions: g_ij = u_i,j
do i = 1, 3
if ( id /= i ) then
    i1 = i1cell
    i2 = i2cell
    i2(i) = min( i2(i), i1pml(i) )
    call diffnc( s1, uu, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
    i1 = i1cell
    i2 = i2cell
    i1(i) = max( i1(i), i2pml(i) - 1 )
    call diffnc( s1, uu, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
end if
end do

! PML region, damped direction: g'_ij = d_j*g_ij = v_i,j
select case( id )
case( 1 )
    i1 = i1cell
    i2 = i2cell
    i2(1) = min( i2(1), i1pml(1) )
    call diffnc( s1, vv, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
    do j = i1(1), i2(1)
    i = j + nnoff(1)
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
        s1(j,k,l) = dc2(i) * s1(j,k,l) + dc1(i) * g1(i,k,l,ic)
        g1(i,k,l,ic) = s1(j,k,l)
    end do
    end do
    end do
    i1 = i1cell
    i2 = i2cell
    i1(1) = max( i1(1), i2pml(1) - 1 )
    call diffnc( s1, vv, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
    do j = i1(1), i2(1)
    i = nn(1) - j - nnoff(1)
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
        s1(j,k,l) = dc2(i) * s1(j,k,l) + dc1(i) * g4(i,k,l,ic)
        g4(i,k,l,ic) = s1(j,k,l)
    end do
    end do
    end do
case( 2 )
    i1 = i1cell
    i2 = i2cell
    i2(2) = min( i2(2), i1pml(2) )
    call diffnc( s1, vv, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
    do k = i1(2), i2(2)
    i = k + nnoff(2)
    do l = i1(3), i2(3)
    do j = i1(1), i2(1)
        s1(j,k,l) = dc2(i) * s1(j,k,l) + dc1(i) * g2(j,i,l,ic)
        g2(j,i,l,ic) = s1(j,k,l)
    end do
    end do
    end do
    i1 = i1cell
    i2 = i2cell
    i1(2) = max( i1(2), i2pml(2) - 1 )
    call diffnc( s1, vv, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
    do k = i1(2), i2(2)
    i = nn(2) - k - nnoff(2)
    do l = i1(3), i2(3)
    do j = i1(1), i2(1)
        s1(j,k,l) = dc2(i) * s1(j,k,l) + dc1(i) * g5(j,i,l,ic)
        g5(j,i,l,ic) = s1(j,k,l)
    end do
    end do
    end do
case( 3 )
    i1 = i1cell
    i2 = i2cell
    i2(3) = min( i2(3), i1pml(3) )
    call diffnc( s1, vv, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
    do l = i1(3), i2(3)
    i = l + nnoff(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        s1(j,k,l) = dc2(i) * s1(j,k,l) + dc1(i) * g3(j,k,i,ic)
        g3(j,k,i,ic) = s1(j,k,l)
    end do
    end do
    end do
    i1 = i1cell
    i2 = i2cell
    i1(3) = max( i1(3), i2pml(3) - 1 )
    call diffnc( s1, vv, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
    do l = i1(3), i2(3)
    i = nn(3) - l - nnoff(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        s1(j,k,l) = dc2(i) * s1(j,k,l) + dc1(i) * g6(j,k,i,ic)
        g6(j,k,i,ic) = s1(j,k,l)
    end do
    end do
    end do
end select

! Add contribution to potency
i = 6 - ic - id
if ( ic < id ) then
    w2(:,:,:,i) = 0.5 * s1
elseif ( ic > id ) then
    w2(:,:,:,i) = w2(:,:,:,i) + 0.5 * s1
else
    w1(:,:,:,ic) = s1
end if

end do doid
end do doic

! Strain
do i = 1, 3
    w1(:,:,:,i) = w1(:,:,:,i) * vc
    w2(:,:,:,i) = w2(:,:,:,i) * vc
end do

! Add potency source to strain
if ( source == 'potency' ) then
    call finite_source
    call tensor_point_source
end if

! Strain I/O
call fieldio( '<>', 'e11', w1(:,:,:,1) )
call fieldio( '<>', 'e22', w1(:,:,:,2) )
call fieldio( '<>', 'e33', w1(:,:,:,3) )
call fieldio( '<>', 'e23', w2(:,:,:,1) )
call fieldio( '<>', 'e31', w2(:,:,:,2) )
call fieldio( '<>', 'e12', w2(:,:,:,3) )

! Attenuation
!do j = 1, 2
!do k = 1, 2
!do l = 1, 2
!  i = j + 2 * ( k - 1 ) + 4 * ( l - 1 )
!  z1(j::2,k::2,l::2,:) = c1(i) * z1(j::2,k::2,l::2,:) + c2(i) * w1(j::2,k::2,l::2,:)
!  z2(j::2,k::2,l::2,:) = c1(i) * z2(j::2,k::2,l::2,:) + c2(i) * w2(j::2,k::2,l::2,:)
!end do
!end do
!end do

! Hook's Law: w_ij = lam*g_ij*delta_ij + mu*(g_ij + g_ji)
s1 = lam * ( w1(:,:,:,1) + w1(:,:,:,2) + w1(:,:,:,3 ) )
do i = 1, 3
    w1(:,:,:,i) = 2.0 * mu * w1(:,:,:,i) + s1
    w2(:,:,:,i) = 2.0 * mu * w2(:,:,:,i)
end do

! Add moment source to stress
if ( source == 'moment' ) then
    call finite_source
    call tensor_point_source
end if

! Stress I/O
call fieldio( '<>', 'w11', w1(:,:,:,1) )
call fieldio( '<>', 'w22', w1(:,:,:,2) )
call fieldio( '<>', 'w33', w1(:,:,:,3) )
call fieldio( '<>', 'w23', w2(:,:,:,1) )
call fieldio( '<>', 'w31', w2(:,:,:,2) )
call fieldio( '<>', 'w12', w2(:,:,:,3) )
if ( modulo( it, itstats ) == 0 ) then
    call tensor_norm( s1, w1, w2, i1core, i2core, (/ 1, 1, 1 /) )
    call set_halo( s1, -1.0, i1core, i2core )
    wmax = maxval( s1 )
end if
call fieldio( '>', 'wm2', s1  )

end subroutine

end module

! Acceleration calculation
module m_acceleration
implicit none
contains

subroutine acceleration
use m_globals
use m_diffcn
use m_source
use m_hourglass
use m_bc
use m_rupture
use m_util
use m_fieldio
use m_stats
use m_collective
integer :: i1(3), i2(3), i, j, k, l, ic, iid, id, iq
real :: rr

if ( verb ) write( 0, * ) 'Acceleration'
call set_halo( s1, 0.0, i1node, i2node )

! Loop over component and derivative direction
doic: do ic  = 1, 3
doid: do iid = 1, 3; id = modulo( ic + iid - 2, 3 ) + 1

! Elastic region
! f_i = w_ij,j
i1 = i1node
i2 = i2node
if ( ic == id ) then
    call diffcn( s1, w1, ic, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
else
    i = 6 - ic - id
    call diffcn( s1, w2, i, id, i1, i2, oplevel, bb, xx, dx1, dx2, dx3, dx )
end if

! PML region
! p'_ij + d_j*p_ij = w_ij,j (no summation convention)
! f_i = sum_j( p_ij' )
select case( id )
case( 1 )
    do j = i1(1), min( i2(1), i1pml(1) )
    i = j + nnoff(1)
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
        s1(j,k,l) = dn2(i) * s1(j,k,l) + dn1(i) * p1(i,k,l,ic)
        p1(i,k,l,ic) = p1(i,k,l,ic) + dt * s1(j,k,l)
    end do
    end do
    end do
    do j = max( i1(1), i2pml(1) ), i2(1)
    i = nn(1) - j - nnoff(1) + 1
    do l = i1(3), i2(3)
    do k = i1(2), i2(2)
        s1(j,k,l) = dn2(i) * s1(j,k,l) + dn1(i) * p4(i,k,l,ic)
        p4(i,k,l,ic) = p4(i,k,l,ic) + dt * s1(j,k,l)
    end do
    end do
    end do
case( 2 )
    do k = i1(2), min( i2(2), i1pml(2) )
    i = k + nnoff(2)
    do l = i1(3), i2(3)
    do j = i1(1), i2(1)
        s1(j,k,l) = dn2(i) * s1(j,k,l) + dn1(i) * p2(j,i,l,ic)
        p2(j,i,l,ic) = p2(j,i,l,ic) + dt * s1(j,k,l)
    end do
    end do
    end do
    do k = max( i1(2), i2pml(2) ), i2(2)
    i = nn(2) - k - nnoff(2) + 1
    do l = i1(3), i2(3)
    do j = i1(1), i2(1)
        s1(j,k,l) = dn2(i) * s1(j,k,l) + dn1(i) * p5(j,i,l,ic)
        p5(j,i,l,ic) = p5(j,i,l,ic) + dt * s1(j,k,l)
    end do
    end do
    end do
case( 3 )
    do l = i1(3), min( i2(3), i1pml(3) )
    i = l + nnoff(3)
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        s1(j,k,l) = dn2(i) * s1(j,k,l) + dn1(i) * p3(j,k,i,ic)
        p3(j,k,i,ic) = p3(j,k,i,ic) + dt * s1(j,k,l)
    end do
    end do
    end do
    do l = max( i1(3), i2pml(3) ), i2(3)
    i = nn(3) - l - nnoff(3) + 1
    do k = i1(2), i2(2)
    do j = i1(1), i2(1)
        s1(j,k,l) = dn2(i) * s1(j,k,l) + dn1(i) * p6(j,k,i,ic)
        p6(j,k,i,ic) = p6(j,k,i,ic) + dt * s1(j,k,l)
    end do
    end do
    end do
end select
 
! Add contribution to force vector
if ( ic == id ) then
    w1(:,:,:,ic) = s1
else
    w1(:,:,:,ic) = w1(:,:,:,ic) + s1
end if

end do doid
end do doic

! Hourglass control. Only viscous in PML
if ( any( hourglass > 0.0 ) ) then
call set_halo( s1, 0.0, i1cell, i2cell )
call set_halo( s2, 0.0, i1node, i2node )
w2 = hourglass(1) * uu + dt * hourglass(2) * vv
do iq = 1, 4
do ic = 1, 3
    i1 = max( i1pml,     i1cell )
    i2 = min( i2pml - 1, i2cell )
    call hourglassnc( s1, w2, iq, ic, i1, i2 )
    s1 = yy * s1
    i1 = max( i1pml + 1, i1node )
    i2 = min( i2pml - 1, i2node )
    call hourglasscn( s2, s1, iq, i1, i2 )
    if ( hourglass(2) > 0.0 .and. npml > 0 ) then
        do i = 1, 3
            i1 = i1cell
            i2 = i2cell
            i2(i) = min( i2(i), i1pml(i) )
            call hourglassnc( s1, vv, iq, ic, i1, i2 )
            do l = i1(3), i2(3)
            do k = i1(2), i2(2)
            do j = i1(1), i2(1)
                s1(j,k,l) = dt * hourglass(2) * yy(j,k,l) * s1(j,k,l)
            end do
            end do
            end do
            i1 = i1cell
            i2 = i2cell
            i1(i) = max( i1(i), i2pml(i) - 1 )
            call hourglassnc( s1, vv, iq, ic, i1, i2 )
            do l = i1(3), i2(3)
            do k = i1(2), i2(2)
            do j = i1(1), i2(1)
                s1(j,k,l) = dt * hourglass(2) * yy(j,k,l) * s1(j,k,l)
            end do
            end do
            end do
        end do
        do i = 1, 3
            i1 = i1node
            i2 = i2node
            i2(i) = min( i2(i), i1pml(i) )
            call hourglasscn( s2, s1, iq, i1, i2 )
            i1 = i1node
            i2 = i2node
            i1(i) = max( i1(i), i2pml(i) )
            call hourglasscn( s2, s1, iq, i1, i2 )
        end do
    end if
    w1(:,:,:,ic) = w1(:,:,:,ic) - s2
end do
end do
end if

! Add source to force
if ( source == 'force' ) then
    call finite_source
    call vector_point_source
end if

! Nodal force input
call fieldio( '<', 'f1', w1(:,:,:,1) )
call fieldio( '<', 'f2', w1(:,:,:,2) )
call fieldio( '<', 'f3', w1(:,:,:,3) )

! Boundary conditions
call vector_bc( w1, bc1, bc2, i1bc, i2bc )

! Spontaneous rupture
call rupture

! Swap halo
rr = timer( 2 )
call vector_swap_halo( w1, nhalo )
if (sync) call barrier
mptimer = mptimer + timer( 2 )

! Nodal force output
call fieldio( '>', 'f1', w1(:,:,:,1) )
call fieldio( '>', 'f2', w1(:,:,:,2) )
call fieldio( '>', 'f3', w1(:,:,:,3) )

! Newton's law: a_i = f_i / m
do i = 1, 3
    w1(:,:,:,i) = w1(:,:,:,i) * mr
end do

! Acceleration I/O
call fieldio( '<>', 'a1', w1(:,:,:,1) )
call fieldio( '<>', 'a2', w1(:,:,:,2) )
call fieldio( '<>', 'a3', w1(:,:,:,3) )
if ( modulo( it, itstats ) == 0 ) then
    call vector_norm( s1, w1, i1core, i2core, (/ 1, 1, 1 /) )
    call set_halo( s1, -1.0, i1core, i2core )
    amax = maxval( s1 )
end if
call fieldio( '>', 'am2', s1  )

end subroutine

end module

! SORD main program
program sord

! Modules
use m_collective
use m_globals
use m_parameters
use m_setup
use m_arrays
use m_grid_gen
use m_fieldio
use m_material
use m_source
use m_rupture
use m_resample
use m_checkpoint
use m_timestep
use m_stress
use m_acceleration
use m_util
use m_stats
implicit none
integer :: jp = 0, fh(9)
real :: prof0(14) = 0.0
real, allocatable :: prof(:,:)

! Initialization
iotimer = 0.0
prof0(1) = timer(0)
call initialize( np0, ip, master )                ; prof0(1)  = timer(6)
call read_parameters                              ; prof0(2)  = timer(6)
call setup               ; if (sync) call barrier ; prof0(3)  = timer(6)
if ( master ) write( 0, * ) 'SORD - Support Operator Rupture Dynamics'
call look_for_checkpoint ; if (sync) call barrier ; prof0(4)  = timer(6)
call arrays              ; if (sync) call barrier ; prof0(5)  = timer(6)
call grid_gen            ; if (sync) call barrier ; prof0(6)  = timer(6)
call material            ; if (sync) call barrier ; prof0(7)  = timer(6)
call pml                 ; if (sync) call barrier ; prof0(8)  = timer(6) 
call finite_source_init  ; if (sync) call barrier ; prof0(9)  = timer(6)
call rupture_init        ; if (sync) call barrier ; prof0(10) = timer(6)
call resample            ; if (sync) call barrier ; prof0(11) = timer(6)
call read_checkpoint     ; if (sync) call barrier ; prof0(12) = timer(6)
fh = -1
if ( mpout /= 0 ) fh = file_null
allocate( prof(8,itio) )
prof0(13) = iotimer
prof0(14) = timer(7)
if ( master ) call rio1( fh(9), prof0, 'w', 'prof/main', 16, 0, mpout, verb )
prof0(14) = timer(7)

! Main loop
if ( master ) write( 0, * ) 'Main loop:', nt, ' steps'
loop: do while ( it < nt )
it = it + 1
jp = jp + 1
mptimer = 0.0
iotimer = 0.0
prof(1,jp) = timer(5)
call timestep            ; if (sync) call barrier ; prof(1,jp) = timer(5)
call stress              ; if (sync) call barrier ; prof(2,jp) = timer(5)
call acceleration        ; if (sync) call barrier ; prof(3,jp) = timer(5)
call stats               ; if (sync) call barrier ; prof(4,jp) = timer(5)
call write_checkpoint    ; if (sync) call barrier ; prof(5,jp) = timer(5)
prof(6,jp) = mptimer
prof(7,jp) = iotimer
prof(8,jp) = timer(6)
if ( it == nt .or. modulo( it, itio ) == 0 ) then
    if ( master ) then
        call rio1( fh(1), prof(1,:jp), 'w', 'prof/1time',   nt, it-jp, mpout, verb )
        call rio1( fh(2), prof(2,:jp), 'w', 'prof/2stress', nt, it-jp, mpout, verb )
        call rio1( fh(3), prof(3,:jp), 'w', 'prof/3accel',  nt, it-jp, mpout, verb )
        call rio1( fh(4), prof(4,:jp), 'w', 'prof/4stats',  nt, it-jp, mpout, verb )
        call rio1( fh(5), prof(5,:jp), 'w', 'prof/5ckpt',   nt, it-jp, mpout, verb )
        call rio1( fh(6), prof(6,:jp), 'w', 'prof/6mp',     nt, it-jp, mpout, verb )
        call rio1( fh(7), prof(7,:jp), 'w', 'prof/7io',     nt, it-jp, mpout, verb )
        call rio1( fh(8), prof(8,:jp), 'w', 'prof/8step',   nt, it-jp, mpout, verb )
        open( 1, file='currentstep', status='replace' )
        write( 1, * ) it
        close( 1 )
    end if
    jp = 0
end if
if ( master .and. it == itstop ) stop
end do loop

! Finish up
if ( sync ) call barrier
prof0(1) = timer(7)
prof0(2) = timer(8)
if ( master ) then
    call rio1( fh(9), prof0(:2), 'w', 'prof/main', 16, 14, mpout, verb )
    write( 0, * ) 'Finished!'
end if
call finalize

end program

